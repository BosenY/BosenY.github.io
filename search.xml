<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>about-seo-meta</title>
      <link href="/2018/07/25/about-seo-meta/"/>
      <url>/2018/07/25/about-seo-meta/</url>
      <content type="html"><![CDATA[<h2 id="Meta-Description"><a href="#Meta-Description" class="headerlink" title="Meta Description"></a>Meta Description</h2><p>描述标签，是 html 代码中以简短描述网页内容的一个标签，其格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"这是网页的描述信息"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>你在描述标签中所写的内容，并不会呈现在网页上被使用者所看到，只有在原始码和搜索结果中才可以看见。</p><p>meta description 不是排名的因素之一，但它会影响到点击率，还有  关键字搜寻结果中所呈现的摘要为何。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>具备叙述性、吸引使用者</li><li>每页使用独特的 meta description</li><li>对于社群分享等，分享的默认文字将会是 meta description</li><li>对于长度来说，一般不要太多</li></ul><p>这里还有一篇文章: <a href="https://support.google.com/webmasters/answer/7451184?hl=zh-Hans" target="_blank" rel="noopener">https://support.google.com/webmasters/answer/7451184?hl=zh-Hans</a></p>]]></content>
      
      <categories>
          
          <category> SEO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SEO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Next.js 引入多个style文件上的一些小问题</title>
      <link href="/2018/07/07/nextjs-multiple-style-file/"/>
      <url>/2018/07/07/nextjs-multiple-style-file/</url>
      <content type="html"><![CDATA[<p>Next.js 是  一个非常好用，并且极易上手的 React-Server-Side-Render Framework，而且支持了很多的一些玩法和操作，也可以  去配置 router、redux、mobx、ts、flow、immutable、graphql、apollo 等、但是样式引用上却还是没办法有一种类似 vue 的方式。</p><p>目前  大致有几种思路处理样式： css-in-js、webpack 打包 + css module 、自己写完用 gulp 或者 rollup 等打包工具来自行打包</p><a id="more"></a><p>目前  我采用的是  第二种方式，也是最接近 vue scoped css/less/sass/stylus 的方式。</p><p>这个是我的 next.config.js 里面的配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> withPlugins = <span class="built_in">require</span>(<span class="string">'next-compose-plugins'</span>)</span><br><span class="line"><span class="keyword">const</span> withLess = <span class="built_in">require</span>(<span class="string">'@zeit/next-less'</span>)</span><br><span class="line"><span class="keyword">const</span> withCss = <span class="built_in">require</span>(<span class="string">'@zeit/next-css'</span>)</span><br><span class="line"><span class="keyword">const</span> withSass = <span class="built_in">require</span>(<span class="string">'@zeit/next-sass'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = withPlugins([</span><br><span class="line">  [</span><br><span class="line">    withLess,</span><br><span class="line">    &#123;</span><br><span class="line">      cssModules: <span class="literal">false</span>,</span><br><span class="line">      lessLoaderOptions: &#123;</span><br><span class="line">        javascriptEnabled: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  [</span><br><span class="line">    withCss,</span><br><span class="line">    &#123;</span><br><span class="line">      cssModules: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  [</span><br><span class="line">    withSass,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// cssModules: false</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>上面的就是用到了一个 compose 的库来完成一个多个 plugins 同时使用的操作（和 koa 里面的 compose 还有 redux 里面的都是一个意思）</p><p>不写 css module 的原因是因为想去引一些第三方的组件，但是发现即时不采用 cssModule，如果我写成类似于 vue 那种一个.vue 文件去引入对应的一个 style 文件，然后一个 component 也对应引入一个 style，最终就除了问题（看 issue 目前  应该是还不能这样写-_-）</p><p> 不能的话，引入组件库，按需引入那种，本质上是没有问题的。可是  我们想引入一下 antd 的个别几个组件时，发现它居然有全局样式，结果和我们的公共组件的样式覆盖了。。。 算了还是自己写吧。</p><p>就只能将所有的样式文件（page 的和 component 的）全部引入到一个文件下，再放到_document.js 当中（建议放_app 当中，我看 issue 里作者说应该放_app.js）</p><p>然后就只能给自己定义一套样式的写法规范，按照 page 名称和 component 名称去命名 style，放在统一的 pages 和 components 文件夹下。</p><p>不知道什么时候写样式能够像 vue 那种，也不是 css module 那种，就类似于</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style jsx scoped&gt;</span><br><span class="line">  <span class="string">` @import './style.less'; `</span></span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure><p>欢迎来探讨一下这个问题，可能是我想的还不够仔细，可能会有更好的办法，都欢迎大佬来评论。</p>]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Next.js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Cannot launch AVD on macOS High Sierra 10.13.4</title>
      <link href="/2018/06/17/cannot-launch-avd-on-mac/"/>
      <url>/2018/06/17/cannot-launch-avd-on-mac/</url>
      <content type="html"><![CDATA[<p>使用 android studio 编译 RN 时，打开模拟器会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">emulator: WARNING: encryption is off</span><br><span class="line">Hax is enabled</span><br><span class="line">Hax ram_size 0x60000000</span><br><span class="line">Failed to open vm 3</span><br><span class="line">Failed to create HAX VM</span><br><span class="line">No accelerator found.</span><br><span class="line">failed to initialize HAX: Invalid argument</span><br></pre></td></tr></table></figure><p>原因是 HAXM 导致的，然后我试了一下直接在 sdk tools 里面更新，但是并没有修复，最终是直接去 <a href="https://software.intel.com/en-us/android/articles/intel-hardware-accelerated-execution-manager-end-user-license-agreement-macosx" target="_blank" rel="noopener">https://software.intel.com/en-us/android/articles/intel-hardware-accelerated-execution-manager-end-user-license-agreement-macosx</a> 这里下载的。</p><p>然后重启电脑就好了。</p>]]></content>
      
      <categories>
          
          <category> React Native </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React Native </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>记一次前端面经</title>
      <link href="/2018/05/29/interview-exp/"/>
      <url>/2018/05/29/interview-exp/</url>
      <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>作为一个双非一本渣校，还不是应届（去年毕业的），个人还是很想去大公司氛围好的团队（虽然很菜但是还是想去哈哈），然后就选了上海的两件比较不错的去面试：携程和哈罗单车。</p><a id="more"></a><h2 id="携程"><a href="#携程" class="headerlink" title="携程"></a>携程</h2><p>我是在 Boss 直聘上投的，因为公司业务也算是和携程相近，所以就想试试，投的第二天就收到了 hr 的信息，然后简单聊了几个问题：你简历上怎么写的毕业后至今职位是打杂？（下次不会这样了，就是自嘲一下的） 跟 hr 解释了一番之后，邀请了去面试。</p><p>一大早去的凌空 soho，感觉满满的一股互联网的年轻气息，人山人海。</p><p>到了之后联系 hr，hr 小姐姐相当热情，告诉我指示以后跟着指示进了办公区，然后开始等面试官，大约等了半个多小时（反正我倒也无所谓），面试官开完会终于来了，态度挺不错的，然后先让我做个自我介绍，我就总结了一下现在手头的一些工作之类的。然后就进入正式的面试环节了：</p><p>问的基本都是原生 js 的东西，就把自己能记住的写下来：</p><ul><li>什么是闭包？(说了点闭包，然后还有闭包的 gc)</li><li>ajax 实现（就是 XMLHttpRequest 那里的东西)</li><li>给你一个移动端翻页的需求，你会怎么做？（监听滚动到底部，讲了一下节流函数，然后还有图片懒加载，然后弄个动画之类的)</li><li>cookie 和 storage 区别</li><li>事件捕获和事件冒泡（这里记得不清楚了，就答了一个捕获是由外到内，冒泡是由内到外）</li><li>跨域，优化（我顺带还把 cors 然后携带 cookie 那里说了一下）</li><li>总结下你能想到的操作 dom 的方法(jq 的、document 上的 getElementById/ClassName/TagName/Name，还有 querySelector、querySelectorAll 就想起这些)</li><li>setTimeout 的运行机制（eventloop 机制）</li><li>说一下 dom 上面的属性的功能和用途（把 vue 里面所用的讲了一下）</li><li>如何实现一个数据驱动（又把 vue 的讲了一下哈哈）</li><li>在调试一个页面的时候鼠标一直在闪，你会从哪几个方面去找问题的原因</li><li>性能优化</li><li>还有的想不起来了，待补充</li><li>你还有什么想问的吗</li></ul><p>总体来说感觉面得蛮爽也蛮久的，最后谈了很多关于他们的部门业务还有想招什么样的人，面试官中间也会给一些提示什么的，就是最后那个题感觉比较懵逼，实在不太好答（其实我是想说是不是写了一个无限 reload 之类的才一直闪或者 chrome 内存溢出之类的哈哈）</p><p>能够从里面总结一些自己的不足和今后需要努力的，比较细的一个方向吧。</p><p>中午出来拍了张照片，随便拍的哈哈：</p><p><img src="/images/ctrip.jpg" alt="中午的凌空soho"></p><h2 id="哈罗单车"><a href="#哈罗单车" class="headerlink" title="哈罗单车"></a>哈罗单车</h2><p>这里是两面， 而且这次的除了穿插一些 es6es7 的东西以外主要问了好多 vue 当中的东西：（问的挺多的能记住多少写多少吧。。）</p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ul><li>vue1 向 2 迁移（没迁移过，只记得钩子函数名称变了，然后还有 sync。）</li><li>子向父组件通信（子组件$emit 父组件监听，$parent 访问父组件，sync 修饰符-2.3 加的，然后问 vue1 和 vue2 的 sync 的原理，我知道 2 的其实就是个语法糖，1 没看过，sync 用在解析一个复杂表达式的时候有问题也没去了解）</li><li>数组搜索值（includes、indexOf），有啥区别（想了半天最后终于想起来：<code>NaN</code>）</li><li>typeof、instanceof、Object.defineProperty 这些</li><li>es6 有啥不好用 es5 去实现的吗（Symbol、Map、WeakMap 这些，原因巴拉巴拉）</li><li>seo （然后就巴拉巴拉把 ssr 和 spa 区别啥的都说了，还有 ssr 原理，然后还有确定你的目的性，如果只是部分页面想要 seo，只需要 prerender 并不要 seo 要明白最终目的）</li><li> 你知道 webpack 吗？说说理解什么的</li><li>引一个 lodash 要怎么样打包（CommonsChunkPlugin 来公用模块拆出来，webpack4 不用这个写，在 optimization 写一个 splitChunks）</li><li>代码分割（ 用上面的拆分公共模块防止重复，css 也有一个 plugin 去分离，然后用动态导入的方式-&gt; vue-router 懒加载）</li><li>最终你发现打包出来有点问题，你会怎么去找问题，怎么看（web 官方文档有，有 3 种方法，还好用过 23333）</li><li>vue 双向绑定相关（数组那里只能重写数组的方法，因为 Object.defineProperty 没办法去监听数组的 set，然后把 Proxy 说一下，在 set 时候去触发 Dep 的 notify,然后用 return Reflect.set(target, name, value, receiver)）</li><li>还有什么想问我的</li><li>还有一些忘了，想起来加上</li></ul><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>二面是 leader 面，问了好多发散性的问题吧，可能自己答得不太好：</p><ul><li> 你第一个项目负责的部分，主要做了哪些功能</li><li>说一下具体的一个实现</li><li>你读过哪些源码</li><li>简单讲一个你读的最深刻的源码</li><li>说一说你读源码的一些心得，你从源码当中  学到了什么</li><li>性能优化</li><li>对自己的定位，规划</li><li>平常去哪些地方学习、遇到过比较棘手的问题</li><li>为什么想跳槽，为什么投我们</li><li>还有什么想问我的</li></ul><p>面试官很 nice，人也很好，问的问题也相当有深度，就是感觉脑壳像被挖干了一样很难受哈哈</p>]]></content>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>koa源码学习</title>
      <link href="/2018/04/29/koa-source-code-analysis/"/>
      <url>/2018/04/29/koa-source-code-analysis/</url>
      <content type="html"><![CDATA[<p>最近新开了2个repo，一个用来记录一些常用网站：<a href="https://github.com/BosenY/bookmarks" target="_blank" rel="noopener">bookmarks</a>，另一个记录对koa源码的理解：<a href="https://github.com/BosenY/LearnNodejs-Koa" target="_blank" rel="noopener">LearnNodejs-Koa</a>。 是直接在源码上做的注释。里面还有阅读深入浅出Nodejs的一些理解。</p><p>现在开始看Vue的，尽量在理解完写完注释后把要点记录在博客里。</p><p>自己以前看不懂的东西拿来重新看，就感觉比以前通透了一些，以后还会继续回头看，哈哈。</p><p>五一还是要出去玩玩的，顺便练习一下拍照，毕竟准备要走了，总得把景点赶紧逛完才不留遗憾。</p>]]></content>
      
      <categories>
          
          <category> 个人小纪 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 后端. </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>koa2-compose学习</title>
      <link href="/2018/04/16/koa2-compose/"/>
      <url>/2018/04/16/koa2-compose/</url>
      <content type="html"><![CDATA[<p>最近在一点一点学习koa源码和深入浅出Node.js那本书，因为现在egg也是基于koa2的，而且自己以前做毕设的时候也用过，<code>async/await</code>真的是太好用了；现在新的中间层用egg搭建，所以想彻底把这部分的东西好好系统看一遍。</p><a id="more"></a><p>从开始看先看到了koa的一个构造函数，然后根据Node原生的写法看，它的真正创建服务的代码在<code>listen()</code>当中:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.proxy = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.middleware = [];</span><br><span class="line">    <span class="keyword">this</span>.subdomainOffset = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.env = process.env.NODE_ENV || <span class="string">'development'</span>;</span><br><span class="line">    <span class="keyword">this</span>.context = <span class="built_in">Object</span>.create(context);</span><br><span class="line">    <span class="keyword">this</span>.request = <span class="built_in">Object</span>.create(request);</span><br><span class="line">    <span class="keyword">this</span>.response = <span class="built_in">Object</span>.create(response);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">listen(...args) &#123;</span><br><span class="line">    debug(<span class="string">'listen'</span>);</span><br><span class="line">    <span class="keyword">const</span> server = http.createServer(<span class="keyword">this</span>.callback());</span><br><span class="line">    <span class="keyword">return</span> server.listen(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在看深入浅出Node.js那本书里面，知道具体的request和response都是在这个callback里面执行，所以就看这个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">callback() &#123;</span><br><span class="line">   <span class="keyword">const</span> fn = compose(<span class="keyword">this</span>.middleware);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!<span class="keyword">this</span>.listeners(<span class="string">'error'</span>).length) <span class="keyword">this</span>.on(<span class="string">'error'</span>, <span class="keyword">this</span>.onerror);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> handleRequest = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">const</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.handleRequest(ctx, fn);</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> handleRequest;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这里其实就是返回了一个<code>handleRequest()</code>,继续看：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">handleRequest(ctx, fnMiddleware) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = ctx.res;</span><br><span class="line">  res.statusCode = <span class="number">404</span>;</span><br><span class="line">  <span class="keyword">const</span> onerror = <span class="function"><span class="params">err</span> =&gt;</span> ctx.onerror(err);</span><br><span class="line">  <span class="keyword">const</span> handleResponse = <span class="function"><span class="params">()</span> =&gt;</span> respond(ctx);</span><br><span class="line">  onFinished(res, onerror);</span><br><span class="line">  <span class="keyword">return</span> fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里基本就能看出来它首先执行的就是这个<code>fn</code>，而这个fn又是怎么执行的？ </p><p>大家都知道它是洋葱式的处理，然后看了一下是放在一个<code>koa-compose</code>的模块当中，这个模块就仅仅几行代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">compose</span> (<span class="params">middleware</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(middleware)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Middleware stack must be an array!'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> middleware) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Middleware must be composed of functions!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @param &#123;Object&#125; context</span></span><br><span class="line"><span class="comment">   * @return &#123;Promise&#125;</span></span><br><span class="line"><span class="comment">   * @api public</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">context, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// last called middleware #</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (i &lt;= index) <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'next() called multiple times'</span>))</span><br><span class="line">      index = i</span><br><span class="line">      <span class="keyword">let</span> fn = middleware[i]</span><br><span class="line">      <span class="keyword">if</span> (i === middleware.length) fn = next</span><br><span class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(context, <span class="function"><span class="keyword">function</span> <span class="title">next</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> dispatch(i + <span class="number">1</span>)</span><br><span class="line">        &#125;))</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面几行都是异常处理，真正的逻辑都在这个return的dispatch(0)当中，然后你发现它就是第一个中间件，首先先去做完一部分第一个中间件的事情，然后到了<code>await next()</code>就要去执行第二个，最终就是一个类似洋葱的模型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="function"><span class="keyword">function</span>(<span class="params">context, next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//中间件一第一部分代码</span></span><br><span class="line">    <span class="keyword">await</span>/<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="function"><span class="keyword">function</span>(<span class="params">context, next</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//中间件二第一部分代码</span></span><br><span class="line">        <span class="keyword">await</span>/<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="function"><span class="keyword">function</span>(<span class="params">context, next</span>)</span>&#123;</span><br><span class="line">                <span class="comment">//中间件三第一部分代码</span></span><br><span class="line">                <span class="keyword">await</span>/<span class="keyword">yield</span> next() <span class="comment">// ...n个</span></span><br><span class="line">                <span class="comment">//中间件三第二部分代码</span></span><br><span class="line">        &#125;())</span><br><span class="line">         <span class="comment">//中间件二第二部分代码</span></span><br><span class="line">    &#125;())</span><br><span class="line">    <span class="comment">//中间件一第二部分代码</span></span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure><p>显而易见这个就是一个洋葱模型，这就是一个简单的koa的中间件调用的实现方式，感觉就可以理解成一个<code>Promise.all()</code></p><p>感觉看完这个，也就对koa的中间件有了一个彻底的认知和理解，那么直接去学习中间件的源码也轻松了很多。</p>]]></content>
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>next-stage</title>
      <link href="/2018/03/28/next-stage/"/>
      <url>/2018/03/28/next-stage/</url>
      <content type="html"><![CDATA[<p>最近比较忙，也没空弄太多，因为开始搭建和架构公司的一个中间层项目(感觉被委以重任蛮开心的)，用的是阿里开源的<a href="https://eggjs.org/" target="_blank" rel="noopener">eggjs</a>  </p><a id="more"></a><p>最近一直再重新温习nodejs一些知识点，以前也就是乱七八糟乱学一通，也没学出个出息来，这次准备看深入浅出nodejs这本书，外加对koa源码进行一个解读，学习一下nodejs框架的一些设计理念。  </p><p>顺便说一下小程序也发布了1.5.1版本，已经有了很多功能: 比方说可以看pokemon的进化关系，特性等，数据是爬完了，但是需要时间一点一点弄，还得再找时间继续完善  </p><p>今天抽空把Lap的一些css问题修复了一下，可能是自己都看不下去了吧~  </p><p>有空再写，eggjs还是蛮好用的，但是架构公司级的中间层，感觉自己压力蛮大的，还是好好看好好学吧。</p>]]></content>
      
      <categories>
          
          <category> 个人小纪 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React高阶组件(转)</title>
      <link href="/2018/03/03/React-high-component/"/>
      <url>/2018/03/03/React-high-component/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>本文代码浅显易懂，思想深入实用。此属于react进阶用法，如果你还不了解react，建议从文档开始看起。</p></blockquote><p>我们都知道高阶函数是什么, 高阶组件其实是差不多的用法，只不过传入的参数变成了react组件，并返回一个新的组件.</p><blockquote><p>A higher-order component is a function that takes a component and returns a new component.<br><a id="more"></a></p></blockquote><p>形如:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EnhancedComponent = higherOrderComponent(WrappedComponent);</span><br></pre></td></tr></table></figure></p><p>高阶组件是react应用中很重要的一部分，最大的特点就是重用组件逻辑。它并不是由React API定义出来的功能，而是由React的组合特性衍生出来的一种设计模式。<br>如果你用过redux，那你就一定接触过高阶组件，因为react-redux中的connect<br>就是一个高阶组件。</p><p>另外本次demo代码都放在 <a href="https://github.com/sunyongjian/hoc-demo" target="_blank" rel="noopener">https://github.com/sunyongjian/hoc-demo</a></p><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>先来一个最简单的高阶组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> simpleHoc <span class="keyword">from</span> <span class="string">'./simple-hoc'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Usual</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props, <span class="string">'props'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Usual</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default simpleHoc(Usual);</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> simpleHoc = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'simpleHoc'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">export default simpleHoc;</span></span><br></pre></td></tr></table></figure><p>组件Usual通过simpleHoc的包装，打了一个log… 那么形如simpleHoc就是一个高阶组件了，通过接收一个组件class Usual，并返回一个组件class。 其实我们可以看到，在这个函数里，我们可以做很多操作。 而且return的组件同样有自己的生命周期，function，另外，我们看到也可以把props传给WrappedComponent(被包装的组件)。 高阶组件的定义我都是用箭头函数去写的，如有不适请参照<a href="http://es6.ruanyifeng.com/#docs/function#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">arrow function</a></p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>高阶组件可以看做是装饰器模式(Decorator Pattern)在React的实现。即允许向一个现有的对象添加新的功能，同时又不改变其结构，属于包装模式(Wrapper Pattern)的一种</p><p>ES7中添加了一个decorator的属性，使用@符表示，可以更精简的书写。那上面的例子就可以改成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> simpleHoc <span class="keyword">from</span> <span class="string">'./simple-hoc'</span>;</span><br><span class="line"></span><br><span class="line">@simpleHoc</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Usual</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Usual</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>是同样的效果。<br>当然兼容性是存在问题的，通常都是通过babel去编译的。 babel提供了plugin，高阶组件用的是类装饰器，所以用transform-decorators-legacy</p><h2 id="两种形式"><a href="#两种形式" class="headerlink" title="两种形式"></a>两种形式</h2><p><br></p><h3 id="属性代理"><a href="#属性代理" class="headerlink" title="属性代理"></a>属性代理</h3><p>引入里我们写的最简单的形式，就是属性代理(Props Proxy)的形式。通过hoc包装wrappedComponent，也就是例子中的Usual，本来传给Usual的props，都在hoc中接受到了，也就是props proxy。 由此我们可以做一些操作</p><ul><li>操作props<br>最直观的就是接受到props，我们可以做任何读取，编辑，删除的很多自定义操作。包括hoc中定义的自定义事件，都可以通过props再传下去。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> propsProxyHoc = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span></span></span></span><br><span class="line"><span class="xml">      &#123;...this.props&#125;</span></span><br><span class="line"><span class="xml">      handleClick=&#123;this.handleClick&#125;</span></span><br><span class="line"><span class="xml">    /&gt;);</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br><span class="line"><span class="xml">export default propsProxyHoc;</span></span><br></pre></td></tr></table></figure></li></ul><p>然后我们的Usual组件render的时候, console.log(this.props) 会得到handleClick.</p><ul><li><p>refs获取组件实例<br>当我们包装Usual的时候，想获取到它的实例怎么办，可以通过引用(ref),在Usual组件挂载的时候，会执行ref的回调函数，在hoc中取到组件的实例。通过打印，可以看到它的props， state，都是可以取到的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> refHoc = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.instanceComponent, <span class="string">'instanceComponent'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span></span></span></span><br><span class="line"><span class="xml">      &#123;...this.props&#125;</span></span><br><span class="line"><span class="xml">      ref=&#123;instanceComponent =&gt; this.instanceComponent = instanceComponent&#125;</span></span><br><span class="line"><span class="xml">    /&gt;);</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">export default refHoc;</span></span><br></pre></td></tr></table></figure></li><li><p>抽离state</p></li></ul><p>这里不是通过ref获取state， 而是通过 { props, 回调函数 } 传递给wrappedComponent组件，通过回调函数获取state。这里用的比较多的就是react处理表单的时候。通常react在处理表单的时候，一般使用的是受控组件<a href="https://facebook.github.io/react/docs/forms.html#controlled-components" target="_blank" rel="noopener">（文档）</a>，即把input都做成受控的，改变value的时候，用onChange事件同步到state中。当然这种操作通过Container组件也可以做到，具体的区别放到后面去比较。看一下代码就知道怎么回事了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通组件Login</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> formCreate <span class="keyword">from</span> <span class="string">'./form-create'</span>;</span><br><span class="line"></span><br><span class="line">@formCreate</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;label id=<span class="string">"username"</span>&gt;</span><br><span class="line">            账户</span><br><span class="line">          &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">          &lt;input name="username" &#123;...this.props.getField('username')&#125;/</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;label id="password"&gt;</span></span><br><span class="line"><span class="regexp">            密码</span></span><br><span class="line"><span class="regexp">          &lt;/</span>label&gt;</span><br><span class="line">          &lt;input name=<span class="string">"password"</span> &#123;...this.props.getField(<span class="string">'password'</span>)&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div onClick=&#123;this.props.handleSubmit&#125;&gt;提交&lt;/</span>div&gt;</span><br><span class="line">        &lt;div&gt;other content&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//HOC</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> formCreate = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      fields: &#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onChange = <span class="function"><span class="params">key</span> =&gt;</span> e =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      fields: &#123;</span><br><span class="line">        ...this.state.fields,</span><br><span class="line">        [key]: e.target.value,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.fields);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getField = <span class="function"><span class="params">fieldName</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      onChange: <span class="keyword">this</span>.onChange(fieldName),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> props = &#123;</span><br><span class="line">      ...this.props,</span><br><span class="line">      handleSubmit: <span class="keyword">this</span>.handleSubmit,</span><br><span class="line">      getField: <span class="keyword">this</span>.getField,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span></span></span></span><br><span class="line"><span class="xml">      &#123;...props&#125;</span></span><br><span class="line"><span class="xml">    /&gt;);</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br><span class="line"><span class="xml">export default formCreate;</span></span><br></pre></td></tr></table></figure></p><p>这里我们把state，onChange等方法都放到HOC里，其实是遵从的react组件的一种规范，子组件简单，傻瓜，负责展示，逻辑与操作放到Container。比如说我们在HOC获取到用户名密码之后，再去做其他操作，就方便多了，而state，处理函数放到Form组件里，只会让Form更加笨重，承担了本不属于它的工作，这样我们可能其他地方也需要用到这个组件，但是处理方式稍微不同，就很麻烦了。</p><h3 id="反向继承"><a href="#反向继承" class="headerlink" title="反向继承"></a>反向继承</h3><p>反向继承(Inheritance Inversion)，简称II，本来我是叫继承反转的…因为有个模式叫控制反转嘛…<br>跟属性代理的方式不同的是，II采用通过 去继承WrappedComponent，本来是一种嵌套的关系，结果II返回的组件却继承了WrappedComponent，这看起来是一种反转的关系。<br>通过继承WrappedComponent，除了一些静态方法，包括生命周期，state，各种function，我们都可以得到。上栗子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// usual</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> iiHoc <span class="keyword">from</span> <span class="string">'./ii-hoc'</span>;</span><br><span class="line"></span><br><span class="line">@iiHoc</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Usual</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      usual: <span class="string">'usual'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'didMount'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Usual</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/IIHOC</span></span><br><span class="line"><span class="regexp">import React from 'react';</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const iiHoc = WrappedComponent =&gt; class extends WrappedComponent &#123;</span></span><br><span class="line"><span class="regexp">    render() &#123;</span></span><br><span class="line"><span class="regexp">      console.log(this.state, 'state');</span></span><br><span class="line"><span class="regexp">      return super.render();</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default iiHoc;</span></span><br></pre></td></tr></table></figure></p><p>iiHoc return的组件通过继承，拥有了Usual的生命周期及属性，所以didMount会打印，state也通过constructor执行，得到state.usual。<br>其实，你还可以通过II：</p><ul><li>渲染劫持<br>这里HOC里定义的组件继承了WrappedComponent的render(渲染)，我们可以以此进行hijack(劫持)，也就是控制它的render函数。栗子：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hijack-hoc</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hijackRenderHoc = <span class="function"><span class="params">config</span> =&gt;</span> WrappedComponent =&gt; <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; style = &#123;&#125; &#125; = config;</span><br><span class="line">    <span class="keyword">const</span> elementsTree = <span class="keyword">super</span>.render();</span><br><span class="line">    <span class="built_in">console</span>.log(elementsTree, <span class="string">'elementsTree'</span>);</span><br><span class="line">    <span class="keyword">if</span> (config.type === <span class="string">'add-style'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;...style&#125;&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;elementsTree&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elementsTree;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> hijackRenderHoc;</span><br><span class="line"><span class="comment">//usual</span></span><br><span class="line">@hijackRenderHoc(&#123;<span class="attr">type</span>: <span class="string">'add-style'</span>, <span class="attr">style</span>: &#123; <span class="attr">color</span>: <span class="string">'red'</span>&#125;&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Usual</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>我这里通过二阶函数，把config参数预制进HOC， 算是一种柯理化的思想。<br>栗子很简单，这个hoc就是添加样式的功能。但是它暴露出来的信息却不少。首先我们可以通过config参数进行逻辑判断，有条件的渲染，当然这个参数的作用很多，react-redux中的connect不就是传入了props-key 嘛。再就是我们还可以拿到WrappedComponent的元素树，可以进行修改操作。最后就是我们通过div包裹，设置了style。但其实具体如何操作还是根据业务逻辑去处理的…</p><p><img src="https://user-images.githubusercontent.com/18378034/27580292-bc808a92-5b5c-11e7-9ad4-afec34cab854.png"></p><h3 id="我的应用场景"><a href="#我的应用场景" class="headerlink" title="我的应用场景"></a>我的应用场景</h3><ul><li><p>通常我会通过高阶组件去优化之前老项目写的不好的地方，比如两个页面UI几乎一样，功能几乎相同，仅仅几个操作不太一样，却写了两个耦合很多的页面级组件。当我去维护它的时候，由于它的耦合性过多，经常会添加一个功能(这两个组件都要添加)，我要去改完第一个的时候，还要改第二个。而且有时候由于我的记性不好，会忘掉第二个… 就会出现bug再返工。更重要的是由于个人比较懒，不想去重构这部分的代码，因为东西太多了，花费太多时间。所以加新功能的时候，我会写一个高阶组件，往HOC里添加方法，把那两个组件包装一下，也就是属性代理。这样新代码就不会再出现耦合，旧的逻辑并不会改变，说不定哪天心情好就会抽离一部分功能到HOC里，直到理想的状态。</p></li><li><p>另一种情况就是之前写过一个组件A，做完上线，之后产品加了一个新需求，很奇怪要做的组件B跟A几乎一模一样，但稍微有区别。那我可能就通过II的方式去继承之前的组件A，比如它在didMount去fetch请求，需要的数据是一样的。不同的地方我就会放到HOC里，存储新的state这样，再通过劫持渲染，把不同的地方，添加的地方进行处理。但其实这算Hack的一种方式，能快速解决问题，也反映了组件设计规划之初有所不足(原因比较多)。</p></li><li><p>Container解决不了的时候甚至不太优雅的时候。其实大部分时候包一层Container组件也能做到差不多的效果，比如操作props，渲染劫持。但其实还是有很大区别的。比如我们现在有两个功能的container，添加样式和添加处理函数的，对Usual进行包装。栗子：</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//usual</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Usual</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props, <span class="string">'props'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      Usual</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Usual;</span><br><span class="line"><span class="comment">//console - Object &#123;handleClick: function&#125;  "props"</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Usual <span class="keyword">from</span> <span class="string">'./usual'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StyleContainer</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> '#<span class="attr">76d0a3</span>' &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>container<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      &lt;Usual &#123;...this.props&#125; /&gt;</span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>);</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">export default StyleContainer;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> StyleContainer <span class="keyword">from</span> <span class="string">'./container-add-style'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FuncContainer</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> props = &#123;</span><br><span class="line">      ...this.props,</span><br><span class="line">      handleClick: <span class="keyword">this</span>.handleClick,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">StyleContainer</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span>);</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">export default FuncContainer;</span></span><br></pre></td></tr></table></figure><p>外层Container必须要引入内层Container，进行包装，还有props的传递，同样要注意包装的顺序。当然你可以把所有的处理都放到一个Container里。那用HOC怎么处理呢，相信大家有清晰的答案了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addFunc = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> props = &#123;</span><br><span class="line">      ...this.props,</span><br><span class="line">      handleClick: <span class="keyword">this</span>.handleClick,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const addStyle = WrappedComponent =&gt; class extends Component &#123;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  render() &#123;</span></span><br><span class="line">    return (&lt;div style=&#123;&#123; color: '#76d0a3' &#125;&#125;&gt;</span><br><span class="line">      &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const WrappenComponent = addStyle(addFunc(Usual));</span><br><span class="line"></span><br><span class="line">class WrappedUsual extends Component &#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(this.props, 'props');</span><br><span class="line">    return (&lt;div&gt;</span><br><span class="line">      &lt;WrappedComponent /&gt;</span><br><span class="line">    &lt;/div&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>显然HOC是更优雅一些的，每个HOC都定义自己独有的处理逻辑，需要的时候只需要去包装你的组件。相较于Container的方式，HOC耦合性更低，灵活性更高，可以自由组合，更适合应付复杂的业务。当然当你的需求很简单的时候，还是用Container去自由组合，应用场景需要你清楚。</p><h3 id="注意点-约束"><a href="#注意点-约束" class="headerlink" title="注意点(约束)"></a>注意点(约束)</h3><p>其实官网有很多，简单介绍一下。</p><ul><li><p>最重要的原则就是，注意高阶组件不会修改子组件，也不拷贝子组件的行为。高阶组件只是通过组合的方式将子组件包装在容器组件中，是一个无副作用的纯函数</p></li><li><p>要给hoc添加class名，便于debugger。我上面的好多栗子组件都没写class 名，请不要学我，因为我实在想不出叫什么名了… 当我们在chrome里应用React-Developer-Tools的时候，组件结构可以一目了然，所以DisplayName最好还是加上。<br><img src="https://user-images.githubusercontent.com/18378034/27580322-ce62a6dc-5b5c-11e7-968f-fda656604229.png"></p></li><li><p>静态方法要复制<br>无论PP还是II的方式，WrappedComponent的静态方法都不会复制，如果要用需要我们单独复制。</p></li><li><p>refs不会传递。 意思就是HOC里指定的ref，并不会传递到子组件，如果你要使用最好写回调函数通过props传下去。</p></li><li><p>不要在render方法内部使用高阶组件。简单来说react的差分算法会去比较 NowElement === OldElement, 来决定要不要替换这个elementTree。也就是如果你每次返回的结果都不是一个引用，react以为发生了变化，去更替这个组件会导致之前组件的状态丢失。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// HOC不要放到render函数里面</span></span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">WrappedUsual</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> WrappenComponent = addStyle(addFunc(Usual));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props, <span class="string">'props'</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">WrappedComponent</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>使用compose组合HOC。函数式编程的套路… 例如应用redux中的middleware以增强功能。redux-middleware解析<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addFuncHOC = ...</span><br><span class="line"><span class="keyword">const</span> addStyleHOC = ...<span class="comment">//省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...funcs</span>) =&gt;</span> component =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.lenght === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> component;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> last = funcs[funcs.length - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">return</span> funcs.reduceRight(<span class="function">(<span class="params">res, cur</span>) =&gt;</span> cur(res), last(component));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> WrappedComponent = compose(addFuncHOC, addStyleHOC)(Usual);</span><br></pre></td></tr></table></figure></p><p>关于注意点，官网有所介绍，不再赘述。链接：<a href="https://reactjs.org/docs/higher-order-components.html#dont-mutate-the-original-component.-use-composition." target="_blank" rel="noopener">地址</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>高阶组件最大的好处就是解耦和灵活性，在react的开发中还是很有用的。<br>当然这不可能是高阶组件的全部用法。掌握了它的一些技巧，还有一些限制，你可以结合你的应用场景，发散思维，尝试一些不同的用法。</p><p>原文转自： <a href="https://github.com/sunyongjian/blog/issues/25" target="_blank" rel="noopener">地址</a></p>]]></content>
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>edit-highlight</title>
      <link href="/2018/02/01/edit-highlight/"/>
      <url>/2018/02/01/edit-highlight/</url>
      <content type="html"><![CDATA[<p>把Lap的highlight风格做了一次大的调整，改成了自己最喜欢的atom-one-dark，只不过ES6的语法好像暂时没办法高亮，因为hexo内置hl渲染方法渲染出来的dom节点根本没办法对ES6部分写样式。<br>下面的是效果的展示，暂时也算满意了，可能以后还会进行一次调整。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$initHighlight</span>(<span class="params">block, cls</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cls.search(<span class="regexp">/\bno\-highlight\b/</span>) != <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">return</span> process(block, <span class="literal">true</span>, <span class="number">0x0F</span>) +</span><br><span class="line">             <span class="string">` class="<span class="subst">$&#123;cls&#125;</span>"`</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">/* handle exception */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span> / <span class="number">2</span>; i &lt; classes.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (checkCondition(classes[i]) === <span class="literal">undefined</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'undefined'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> sss = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">export</span>  $initHighlight;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined">body &#123;width: 500px;&#125;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">$init</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">checked</span> <span class="attr">class</span>=<span class="string">"title"</span> <span class="attr">id</span>=<span class="string">'title'</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- here goes the rest of the page --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>日常随笔</title>
      <link href="/2018/01/28/daily-1/"/>
      <url>/2018/01/28/daily-1/</url>
      <content type="html"><![CDATA[<h3 id="关于Lap"><a href="#关于Lap" class="headerlink" title="关于Lap"></a>关于Lap</h3><p>这个theme现在还差个人介绍模块和article模块没有进行优化，其他的可能弄完以后暂时先不更新了<br>不过该有的功能和统计的东西肯定是会一点一点全部完成的</p><p>对于disqus，虽然看了一下其他人分享的如何去走代理设置让国内也可以访问，但我觉得这个办法还是不太好，既然无法成为一种更加通用可配置的方案，那就暂时不考虑了，也不是每个人都会去买一个vps进行配置，索性接这样弄: 3s访问不到就提示需要翻墙才可以进行评论。。 我觉得这样的处理方法比较通用吧。</p><h3 id="近期安排"><a href="#近期安排" class="headerlink" title="近期安排"></a>近期安排</h3><p>最近可能要继续开始加班了，毕竟年末，所以写开源和学习的自由时间可能不是很多，但我想起我有一部分文章放在了简书，所以我决定先搬运一波，然后在把自己学Graphql的一些东西稍微写写，最近就是graphql了，别的也没空看了，等年后吧~</p><p>最近一到周末就沉迷pokemon revolution不能自拔，可能要写一篇去安利一发了，毕竟是很多90后乃至80后满满的回忆~（更重要的是能和老外尬英文、PY）</p>]]></content>
      
      <categories>
          
          <category> 个人小纪 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于最近的折腾</title>
      <link href="/2018/01/18/%E5%85%B3%E4%BA%8E%E6%9C%80%E8%BF%91%E7%9A%84%E6%8A%98%E8%85%BE/"/>
      <url>/2018/01/18/%E5%85%B3%E4%BA%8E%E6%9C%80%E8%BF%91%E7%9A%84%E6%8A%98%E8%85%BE/</url>
      <content type="html"><![CDATA[<p>其实一直想用这个写博客的，但是出现过一次问题：<br>  我在win上面提交都是正常的，但是把项目搞到mac上之后提交就出现了bug，研究了半天也没找到完美解决的办法，这才自己去搭建了一个自己的博客。。<br>  <a id="more"></a></p><p>自己是在搬瓦工的vps上搭建的，采用的是golang的gin + React + Nextjs ，总体上倒是没什么问题，唯一的问题就是cdn解析过慢，毕竟有墙的因素在，感觉身在国内确实也没法避免这个问题，性能上反正我自己是忍受不了了，于是还是回来写这个。。 不过好像也更新了很多，可能好多的插件什么的也不能用了，准备近期好好弄一下，把bug都解决掉。</p>]]></content>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ng-router</title>
      <link href="/2017/09/15/ng-router/"/>
      <url>/2017/09/15/ng-router/</url>
      <content type="html"><![CDATA[<h1 id="ng-router"><a href="#ng-router" class="headerlink" title="ng-router"></a>ng-router</h1><p>ng-router可以把angular1变成一个spa应用，在页面上的原理就是渲染了不同的controller来实现不同的路由，具体实例代码如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>AngularJS 路由实例 - 菜鸟教程<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">ng-app</span>=<span class="string">'routingDemoApp'</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>AngularJS 路由应用<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/computers"</span>&gt;</span>电脑<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/printers"</span>&gt;</span>打印机<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/blabla"</span>&gt;</span>其他<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-view</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://apps.bdimg.com/libs/angular.js/1.4.6/angular.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://apps.bdimg.com/libs/angular-route/1.3.13/angular-route.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">            angular.module(<span class="string">'routingDemoApp'</span>,[<span class="string">'ngRoute'</span>])</span></span><br><span class="line"><span class="javascript">            .config([<span class="string">'$routeProvider'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$routeProvider</span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">                $routeProvider</span></span><br><span class="line"><span class="javascript">                .when(<span class="string">'/'</span>,&#123;<span class="attr">template</span>:<span class="string">'这是首页页面'</span>&#125;)</span></span><br><span class="line"><span class="javascript">                .when(<span class="string">'/computers'</span>,&#123;<span class="attr">template</span>:<span class="string">'这是电脑分类页面'</span>&#125;)</span></span><br><span class="line"><span class="javascript">                .when(<span class="string">'/printers'</span>,&#123;<span class="attr">template</span>:<span class="string">'这是打印机页面'</span>&#125;)</span></span><br><span class="line"><span class="javascript">                .otherwise(&#123;<span class="attr">redirectTo</span>:<span class="string">'/'</span>&#125;);</span></span><br><span class="line"><span class="undefined">            &#125;]);</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>首先，载入了实现路由的js文件：angular-route.js； 然后，包含了ngRoute模块作为主应用模块的依赖模块。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">angular.module(<span class="string">'routingDemoApp'</span>,[<span class="string">'ngRoute'</span>])</span><br></pre></td></tr></table></figure></p><p>使用ngView指令<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ng-view&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>该div内html会根据路由的变化来变化。</p><p>然后配置$routeProvider, 用于定义我们的路由规则</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.config([<span class="string">'$routeProvider'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$routeProvider</span>)</span>&#123;</span><br><span class="line">    $routeProvider</span><br><span class="line">        .when(<span class="string">'/'</span>,&#123;<span class="attr">template</span>:<span class="string">'这是首页页面'</span>&#125;)</span><br><span class="line">        .when(<span class="string">'/computers'</span>,&#123;<span class="attr">template</span>:<span class="string">'这是电脑分类页面'</span>&#125;)</span><br><span class="line">        .when(<span class="string">'/printers'</span>,&#123;<span class="attr">template</span>:<span class="string">'这是打印机页面'</span>&#125;)</span><br><span class="line">        .otherwise(&#123;<span class="attr">redirectTo</span>:<span class="string">'/'</span>&#125;);</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> AngularJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> AngularJS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ngapi</title>
      <link href="/2017/09/15/ngapi/"/>
      <url>/2017/09/15/ngapi/</url>
      <content type="html"><![CDATA[<h1 id="ngApi"><a href="#ngApi" class="headerlink" title="ngApi"></a>ngApi</h1><p>angular JS全局API用于执行常见任务的JS函数集合，如：</p><ul><li>比较对象</li><li>迭代对象</li><li><p>转换对象<br>简单的说就是将一些工作中常用的方法封装到了angular.prototype上了，<br>下面有几个典型的：</p></li><li><p>angular.lowercase() - 转换字符为小写</p></li><li>angular.uppercase() - 转换字符为大写</li><li>angular.isString() - 判断是否是字符串</li><li>angular.isNumber() - 判断是否是数字</li></ul><p>例子： <a src="http://www.runoob.com/try/tryit.php?filename=try_ng_api_lowercase">地址</a></p>]]></content>
      
      <categories>
          
          <category> AngularJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> AngularJS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ng过滤器</title>
      <link href="/2017/09/14/ng-filter/"/>
      <url>/2017/09/14/ng-filter/</url>
      <content type="html"><![CDATA[<h1 id="ng过滤器"><a href="#ng过滤器" class="headerlink" title="ng过滤器"></a>ng过滤器</h1><p>所有的例子会写在这里：<a src="http://jsbin.com/vigiciresi/edit?html,js,output">例子</a></p><p>首先学习一下ng1的过滤器的一个基本写法：</p><p>一个过滤器，不带参数的情况<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;expression | filter&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>一个过滤器，带参数的情况<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;expression | filter:<span class="built_in">arguments</span>&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>一个过滤器，带多个参数的情况<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;expression | filter: arg1: arg2: ...&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>多个过滤器，不带参数的情况<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;expression | filter1 | filter2 | ...&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>先学习自定义的，现找出来10个：</p><h2 id="1-currency"><a href="#1-currency" class="headerlink" title="1. currency"></a>1. currency</h2><p>顾名思义，用于将数字转换为货币的<br>默认的话，是将数字转化成了当前使用语言环境的符号<br>当然也可以设置自定义符号，格式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; currency_expression | currency : symbol : fractionSize&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>其中symbol代表你要自定义的货币符号，fractionSize代表小数位的取舍量</p><h2 id="2-date"><a href="#2-date" class="headerlink" title="2. date"></a>2. date</h2><p>根据要求将时间转换成字符串，开发当中经常用到，<br>格式化的字符串可以由以下原件组成：</p><ul><li>‘yyyy’: 年份用4位数字表示(e.g. AD 1 =&gt; 0001, AD 2010 =&gt; 2010)</li><li>‘yy’: 年份用2位数字表示, 补全0 (00-99). (e.g. AD 2001 =&gt; 01, AD 2010 =&gt; 10)</li><li>‘y’: 年份用最少位数字表示, e.g. (AD 1 =&gt; 1, AD 199 =&gt; 199)</li><li>‘MMMM’: 月份 (January-December)</li><li>‘MMM’: 月份 (Jan-Dec)</li><li>‘MM’: 月份, 补全0 (01-12)</li><li>‘M’: 月份 (1-12)</li><li>‘dd’: 日期, 补全0 (01-31)</li><li>‘d’: 日期 (1-31)</li><li>‘EEEE’: 星期,(Sunday-Saturday)</li><li>‘EEE’: 星期, (Sun-Sat)</li><li>‘HH’: 小时, 补全0 (00-23)</li><li>‘H’: 补全0 (0-23)</li><li>‘hh’: AM/PM 表示的小时, 补全0 (01-12)</li><li>‘h’: AM/PM 表示的小时, (1-12)</li><li>‘mm’: 分钟, 补全0 (00-59)</li><li>‘m’: 分钟 (0-59)</li><li>‘ss’: 秒, 补全0 (00-59)</li><li>‘s’: 秒 (0-59)</li><li>‘sss’: 毫秒, 补全0 (000-999)</li><li>‘a’: AM/PM 标记</li><li>‘Z’: 用4位表示时区的偏移 (-1200-+1200)</li><li>‘ww’: 周数, 补全0 (00-53). 01周是每年的包含第一个周四的周</li><li>‘w’: Week of year (0-53). 01周是每年的包含第一个周四的周</li><li>‘G’, ‘GG’, ‘GGG’: 时代的简写字符串 (e.g. ‘AD’)</li><li>‘GGGG’: 时代的完整字符串 (e.g. ‘Anno Domini’)</li></ul><p>格式字符串还可以是下列预定义的本地化的格式之一:</p><ul><li>‘medium’: en_US 地区的形式，等同于 ‘MMM d, y h:mm:ss a’ (e.g. Sep 3, 2010 12:05:08 PM)</li><li>‘short’: en_US 地区的形式，等同于 ‘M/d/yy h:mm a’ (e.g. 9/3/10 12:05 PM)</li><li>‘fullDate’: en_US 地区的形式，等同于 ‘EEEE, MMMM d, y’ (e.g. Friday, September 3, 2010)</li><li>‘longDate’: en_US 地区的形式，等同于 ‘MMMM d, y’ (e.g. September 3, 2010)</li><li>‘mediumDate’: en_US 地区的形式，等同于 ‘MMM d, y’ (e.g. Sep 3, 2010)</li><li>‘shortDate’: en_US 地区的形式，等同于 ‘M/d/yy’ (e.g. 9/3/10)</li><li>‘mediumTime’: en_US 地区的形式，等同于 ‘h:mm:ss a’ (e.g. 12:05:08 PM)</li><li>‘shortTime’: en_US 地区的形式，等同于 ‘h:mm a’ (e.g. 12:05 PM)</li></ul><p>格式字符串可以包含文字。但是需要使用 ‘ 包裹进行转义 (e.g. “h ‘in the morning’”).<br>如果想使用单引号,则需要转义 - 举个例子, 在一行里有两个单引号 (e.g. “h ‘o’’clock’”).</p>]]></content>
      
      <categories>
          
          <category> AngularJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> AngularJS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于es7bind语法的小纪</title>
      <link href="/2017/04/21/es7bind/"/>
      <url>/2017/04/21/es7bind/</url>
      <content type="html"><![CDATA[<h1 id="有关es7-function-bind-syntax的东西"><a href="#有关es7-function-bind-syntax的东西" class="headerlink" title="有关es7 function bind syntax的东西"></a>有关es7 function bind syntax的东西</h1><p>因为群里有大佬以前提到过，但是因为自己太菜了根本无法理解，所以就去学习了一下。。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>所谓的function bind syntax ，其实就是一个绑定的语法糖，就和箭头函数是类似的（箭头函数是声明函数时绑定this的语法糖，这里就有个坑，用箭头函数声明的方法就不能再使用::去绑定了，不会起作用。。）</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>简单来说<strong>::</strong>有两种作用：</p><ol><li>当::出现在一个对象名的签名，且对象名后面紧跟着一个它的方法名的时候，作用就是把这个对象绑定为这个方法的this</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    method() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">::obj.method</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">obj.method.bind(obj)</span><br></pre></td></tr></table></figure><ol start="2"><li>当::出现在对象和方法名之间的时候，将这个对象绑定为这个方法的this,当然，因为这个绑定后还是一个函数，所以也可以直接调用</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    foo: <span class="string">'bar'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo)</span><br><span class="line">&#125;</span><br><span class="line">obj::method()</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">method.call(obj)()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj::method</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">method.bind(obj)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Ecmascript7 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
