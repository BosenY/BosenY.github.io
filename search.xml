<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[next-stage]]></title>
    <url>%2F2018%2F03%2F28%2Fnext-stage%2F</url>
    <content type="text"><![CDATA[最近比较忙，也没空弄太多，因为开始搭建和架构公司的一个中间层项目(感觉被委以重任蛮开心的)，用的是阿里开源的eggjs 最近一直再重新温习nodejs一些知识点，以前也就是乱七八糟乱学一通，也没学出个出息来，这次准备看深入浅出nodejs这本书，外加对koa源码进行一个解读，学习一下nodejs框架的一些设计理念。 顺便说一下小程序也发布了1.5.1版本，已经有了很多功能: 比方说可以看pokemon的进化关系，特性等，数据是爬完了，但是需要时间一点一点弄，还得再找时间继续完善 今天抽空把Lap的一些css问题修复了一下，可能是自己都看不下去了吧~ 有空再写，eggjs还是蛮好用的，但是架构公司级的中间层，感觉自己压力蛮大的，还是好好看好好学吧。]]></content>
      <categories>
        <category>个人小纪</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React高阶组件(转)]]></title>
    <url>%2F2018%2F03%2F03%2FReact-high-component%2F</url>
    <content type="text"><![CDATA[前言 本文代码浅显易懂，思想深入实用。此属于react进阶用法，如果你还不了解react，建议从文档开始看起。 我们都知道高阶函数是什么, 高阶组件其实是差不多的用法，只不过传入的参数变成了react组件，并返回一个新的组件. A higher-order component is a function that takes a component and returns a new component. 形如:1const EnhancedComponent = higherOrderComponent(WrappedComponent); 高阶组件是react应用中很重要的一部分，最大的特点就是重用组件逻辑。它并不是由React API定义出来的功能，而是由React的组合特性衍生出来的一种设计模式。如果你用过redux，那你就一定接触过高阶组件，因为react-redux中的connect就是一个高阶组件。 另外本次demo代码都放在 https://github.com/sunyongjian/hoc-demo 引入先来一个最简单的高阶组件 1234567891011121314import React, &#123; Component &#125; from 'react';import simpleHoc from './simple-hoc';class Usual extends Component &#123; render() &#123; console.log(this.props, 'props'); return ( &lt;div&gt; Usual &lt;/div&gt; ) &#125;&#125;export default simpleHoc(Usual); 1234567891011import React, &#123; Component &#125; from 'react';const simpleHoc = WrappedComponent =&gt; &#123; console.log('simpleHoc'); return class extends Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125;/&gt; &#125; &#125;&#125;export default simpleHoc; 组件Usual通过simpleHoc的包装，打了一个log… 那么形如simpleHoc就是一个高阶组件了，通过接收一个组件class Usual，并返回一个组件class。 其实我们可以看到，在这个函数里，我们可以做很多操作。 而且return的组件同样有自己的生命周期，function，另外，我们看到也可以把props传给WrappedComponent(被包装的组件)。 高阶组件的定义我都是用箭头函数去写的，如有不适请参照arrow function 装饰器模式高阶组件可以看做是装饰器模式(Decorator Pattern)在React的实现。即允许向一个现有的对象添加新的功能，同时又不改变其结构，属于包装模式(Wrapper Pattern)的一种 ES7中添加了一个decorator的属性，使用@符表示，可以更精简的书写。那上面的例子就可以改成： 12345678910111213import React, &#123; Component &#125; from 'react';import simpleHoc from './simple-hoc';@simpleHocexport default class Usual extends Component &#123; render() &#123; return ( &lt;div&gt; Usual &lt;/div&gt; ) &#125;&#125; 是同样的效果。当然兼容性是存在问题的，通常都是通过babel去编译的。 babel提供了plugin，高阶组件用的是类装饰器，所以用transform-decorators-legacy 两种形式 属性代理引入里我们写的最简单的形式，就是属性代理(Props Proxy)的形式。通过hoc包装wrappedComponent，也就是例子中的Usual，本来传给Usual的props，都在hoc中接受到了，也就是props proxy。 由此我们可以做一些操作 操作props最直观的就是接受到props，我们可以做任何读取，编辑，删除的很多自定义操作。包括hoc中定义的自定义事件，都可以通过props再传下去。12345678910111213141516import React, &#123; Component &#125; from 'react';const propsProxyHoc = WrappedComponent =&gt; class extends Component &#123; handleClick() &#123; console.log('click'); &#125; render() &#123; return (&lt;WrappedComponent &#123;...this.props&#125; handleClick=&#123;this.handleClick&#125; /&gt;); &#125;&#125;;export default propsProxyHoc; 然后我们的Usual组件render的时候, console.log(this.props) 会得到handleClick. refs获取组件实例当我们包装Usual的时候，想获取到它的实例怎么办，可以通过引用(ref),在Usual组件挂载的时候，会执行ref的回调函数，在hoc中取到组件的实例。通过打印，可以看到它的props， state，都是可以取到的。 1234567891011121314151617import React, &#123; Component &#125; from 'react';const refHoc = WrappedComponent =&gt; class extends Component &#123; componentDidMount() &#123; console.log(this.instanceComponent, 'instanceComponent'); &#125; render() &#123; return (&lt;WrappedComponent &#123;...this.props&#125; ref=&#123;instanceComponent =&gt; this.instanceComponent = instanceComponent&#125; /&gt;); &#125;&#125;;export default refHoc; 抽离state 这里不是通过ref获取state， 而是通过 { props, 回调函数 } 传递给wrappedComponent组件，通过回调函数获取state。这里用的比较多的就是react处理表单的时候。通常react在处理表单的时候，一般使用的是受控组件（文档），即把input都做成受控的，改变value的时候，用onChange事件同步到state中。当然这种操作通过Container组件也可以做到，具体的区别放到后面去比较。看一下代码就知道怎么回事了：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 普通组件Loginimport React, &#123; Component &#125; from 'react';import formCreate from './form-create';@formCreateexport default class Login extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;div&gt; &lt;label id="username"&gt; 账户 &lt;/label&gt; &lt;input name="username" &#123;...this.props.getField('username')&#125;/&gt; &lt;/div&gt; &lt;div&gt; &lt;label id="password"&gt; 密码 &lt;/label&gt; &lt;input name="password" &#123;...this.props.getField('password')&#125;/&gt; &lt;/div&gt; &lt;div onClick=&#123;this.props.handleSubmit&#125;&gt;提交&lt;/div&gt; &lt;div&gt;other content&lt;/div&gt; &lt;/div&gt; ) &#125;&#125;//HOCimport React, &#123; Component &#125; from 'react';const formCreate = WrappedComponent =&gt; class extends Component &#123; constructor() &#123; super(); this.state = &#123; fields: &#123;&#125;, &#125; &#125; onChange = key =&gt; e =&gt; &#123; this.setState(&#123; fields: &#123; ...this.state.fields, [key]: e.target.value, &#125; &#125;) &#125; handleSubmit = () =&gt; &#123; console.log(this.state.fields); &#125; getField = fieldName =&gt; &#123; return &#123; onChange: this.onChange(fieldName), &#125; &#125; render() &#123; const props = &#123; ...this.props, handleSubmit: this.handleSubmit, getField: this.getField, &#125; return (&lt;WrappedComponent &#123;...props&#125; /&gt;); &#125;&#125;;export default formCreate; 这里我们把state，onChange等方法都放到HOC里，其实是遵从的react组件的一种规范，子组件简单，傻瓜，负责展示，逻辑与操作放到Container。比如说我们在HOC获取到用户名密码之后，再去做其他操作，就方便多了，而state，处理函数放到Form组件里，只会让Form更加笨重，承担了本不属于它的工作，这样我们可能其他地方也需要用到这个组件，但是处理方式稍微不同，就很麻烦了。 反向继承反向继承(Inheritance Inversion)，简称II，本来我是叫继承反转的…因为有个模式叫控制反转嘛…跟属性代理的方式不同的是，II采用通过 去继承WrappedComponent，本来是一种嵌套的关系，结果II返回的组件却继承了WrappedComponent，这看起来是一种反转的关系。通过继承WrappedComponent，除了一些静态方法，包括生命周期，state，各种function，我们都可以得到。上栗子：1234567891011121314151617181920212223242526272829303132333435363738 // usualimport React, &#123; Component &#125; from 'react';import iiHoc from './ii-hoc';@iiHocexport default class Usual extends Component &#123; constructor() &#123; super(); this.state = &#123; usual: 'usual', &#125; &#125; componentDidMount() &#123; console.log('didMount') &#125; render() &#123; return ( &lt;div&gt; Usual &lt;/div&gt; ) &#125;&#125;//IIHOCimport React from 'react';const iiHoc = WrappedComponent =&gt; class extends WrappedComponent &#123; render() &#123; console.log(this.state, 'state'); return super.render(); &#125;&#125;export default iiHoc; iiHoc return的组件通过继承，拥有了Usual的生命周期及属性，所以didMount会打印，state也通过constructor执行，得到state.usual。其实，你还可以通过II： 渲染劫持这里HOC里定义的组件继承了WrappedComponent的render(渲染)，我们可以以此进行hijack(劫持)，也就是控制它的render函数。栗子：1234567891011121314151617181920212223//hijack-hocimport React from 'react';const hijackRenderHoc = config =&gt; WrappedComponent =&gt; class extends WrappedComponent &#123; render() &#123; const &#123; style = &#123;&#125; &#125; = config; const elementsTree = super.render(); console.log(elementsTree, 'elementsTree'); if (config.type === 'add-style') &#123; return &lt;div style=&#123;&#123;...style&#125;&#125;&gt; &#123;elementsTree&#125; &lt;/div&gt;; &#125; return elementsTree; &#125;&#125;;export default hijackRenderHoc;//usual@hijackRenderHoc(&#123;type: 'add-style', style: &#123; color: 'red'&#125;&#125;)class Usual extends Component &#123; ...&#125; 我这里通过二阶函数，把config参数预制进HOC， 算是一种柯理化的思想。栗子很简单，这个hoc就是添加样式的功能。但是它暴露出来的信息却不少。首先我们可以通过config参数进行逻辑判断，有条件的渲染，当然这个参数的作用很多，react-redux中的connect不就是传入了props-key 嘛。再就是我们还可以拿到WrappedComponent的元素树，可以进行修改操作。最后就是我们通过div包裹，设置了style。但其实具体如何操作还是根据业务逻辑去处理的… 我的应用场景 通常我会通过高阶组件去优化之前老项目写的不好的地方，比如两个页面UI几乎一样，功能几乎相同，仅仅几个操作不太一样，却写了两个耦合很多的页面级组件。当我去维护它的时候，由于它的耦合性过多，经常会添加一个功能(这两个组件都要添加)，我要去改完第一个的时候，还要改第二个。而且有时候由于我的记性不好，会忘掉第二个… 就会出现bug再返工。更重要的是由于个人比较懒，不想去重构这部分的代码，因为东西太多了，花费太多时间。所以加新功能的时候，我会写一个高阶组件，往HOC里添加方法，把那两个组件包装一下，也就是属性代理。这样新代码就不会再出现耦合，旧的逻辑并不会改变，说不定哪天心情好就会抽离一部分功能到HOC里，直到理想的状态。 另一种情况就是之前写过一个组件A，做完上线，之后产品加了一个新需求，很奇怪要做的组件B跟A几乎一模一样，但稍微有区别。那我可能就通过II的方式去继承之前的组件A，比如它在didMount去fetch请求，需要的数据是一样的。不同的地方我就会放到HOC里，存储新的state这样，再通过劫持渲染，把不同的地方，添加的地方进行处理。但其实这算Hack的一种方式，能快速解决问题，也反映了组件设计规划之初有所不足(原因比较多)。 Container解决不了的时候甚至不太优雅的时候。其实大部分时候包一层Container组件也能做到差不多的效果，比如操作props，渲染劫持。但其实还是有很大区别的。比如我们现在有两个功能的container，添加样式和添加处理函数的，对Usual进行包装。栗子： 123456789101112//usualclass Usual extends Component &#123; render() &#123; console.log(this.props, 'props'); return &lt;div&gt; Usual &lt;/div&gt; &#125;&#125;;export default Usual;//console - Object &#123;handleClick: function&#125; "props" 1234567891011121314import React, &#123; Component &#125; from 'react';import Usual from './usual';class StyleContainer extends Component &#123; render() &#123; return (&lt;div style=&#123;&#123; color: '#76d0a3' &#125;&#125;&gt; &lt;div&gt;container&lt;/div&gt; &lt;Usual &#123;...this.props&#125; /&gt; &lt;/div&gt;); &#125;&#125;export default StyleContainer; 123456789101112131415161718import React, &#123; Component &#125; from 'react';import StyleContainer from './container-add-style';class FuncContainer extends Component &#123; handleClick() &#123; console.log('click'); &#125; render() &#123; const props = &#123; ...this.props, handleClick: this.handleClick, &#125;; return (&lt;StyleContainer &#123;...props&#125; /&gt;); &#125;&#125;export default FuncContainer; 外层Container必须要引入内层Container，进行包装，还有props的传递，同样要注意包装的顺序。当然你可以把所有的处理都放到一个Container里。那用HOC怎么处理呢，相信大家有清晰的答案了。12345678910111213141516171819202122232425262728293031323334const addFunc = WrappedComponent =&gt; class extends Component &#123; handleClick() &#123; console.log('click'); &#125; render() &#123; const props = &#123; ...this.props, handleClick: this.handleClick, &#125;; return &lt;WrappedComponent &#123;...props&#125; /&gt;; &#125;&#125;;const addStyle = WrappedComponent =&gt; class extends Component &#123; render() &#123; return (&lt;div style=&#123;&#123; color: '#76d0a3' &#125;&#125;&gt; &lt;WrappedComponent &#123;...this.props&#125; /&gt; &lt;/div&gt;); &#125;&#125;;const WrappenComponent = addStyle(addFunc(Usual));class WrappedUsual extends Component &#123; render() &#123; console.log(this.props, 'props'); return (&lt;div&gt; &lt;WrappedComponent /&gt; &lt;/div&gt;); &#125;&#125; 显然HOC是更优雅一些的，每个HOC都定义自己独有的处理逻辑，需要的时候只需要去包装你的组件。相较于Container的方式，HOC耦合性更低，灵活性更高，可以自由组合，更适合应付复杂的业务。当然当你的需求很简单的时候，还是用Container去自由组合，应用场景需要你清楚。 注意点(约束)其实官网有很多，简单介绍一下。 最重要的原则就是，注意高阶组件不会修改子组件，也不拷贝子组件的行为。高阶组件只是通过组合的方式将子组件包装在容器组件中，是一个无副作用的纯函数 要给hoc添加class名，便于debugger。我上面的好多栗子组件都没写class 名，请不要学我，因为我实在想不出叫什么名了… 当我们在chrome里应用React-Developer-Tools的时候，组件结构可以一目了然，所以DisplayName最好还是加上。 静态方法要复制无论PP还是II的方式，WrappedComponent的静态方法都不会复制，如果要用需要我们单独复制。 refs不会传递。 意思就是HOC里指定的ref，并不会传递到子组件，如果你要使用最好写回调函数通过props传下去。 不要在render方法内部使用高阶组件。简单来说react的差分算法会去比较 NowElement === OldElement, 来决定要不要替换这个elementTree。也就是如果你每次返回的结果都不是一个引用，react以为发生了变化，去更替这个组件会导致之前组件的状态丢失。 12345678910111213 // HOC不要放到render函数里面 class WrappedUsual extends Component &#123; render() &#123; const WrappenComponent = addStyle(addFunc(Usual)); console.log(this.props, 'props'); return (&lt;div&gt; &lt;WrappedComponent /&gt; &lt;/div&gt;); &#125;&#125; 使用compose组合HOC。函数式编程的套路… 例如应用redux中的middleware以增强功能。redux-middleware解析123456789101112const addFuncHOC = ...const addStyleHOC = ...//省略const compose = (...funcs) =&gt; component =&gt; &#123; if (funcs.lenght === 0) &#123; return component; &#125; const last = funcs[funcs.length - 1]; return funcs.reduceRight((res, cur) =&gt; cur(res), last(component));&#125;;const WrappedComponent = compose(addFuncHOC, addStyleHOC)(Usual); 关于注意点，官网有所介绍，不再赘述。链接：地址 总结高阶组件最大的好处就是解耦和灵活性，在react的开发中还是很有用的。当然这不可能是高阶组件的全部用法。掌握了它的一些技巧，还有一些限制，你可以结合你的应用场景，发散思维，尝试一些不同的用法。 原文转自： 地址]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018新年第一篇]]></title>
    <url>%2F2018%2F02%2F24%2F2018%E6%96%B0%E5%B9%B4%E7%AC%AC%E4%B8%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[过年期间没更新博客也没去更新theme的新功能，倒是也没有懒惰，只是趁着过年期间算是可以有一小段修整的时间，一边给自己放了个假，一边也完成了自己一直想做的一个小程序的第一版 -&gt; 精灵宝可梦dex。 最近刚把这个小程序的第一版功能做完，其实我以前倒是也做过小程序，但只是写一点简单的页面和接口对接而已，这次由自己来独立完成一个小程序，可能要考虑的东西蛮多的，比方说: 小程序的加载速度 如何提升小程序的用户体验等 反正也算是将第一版功能保质保量做完了，而且用户体验还不错，不需要进行任何接口调用，我是把数据进行了前期的爬取整理后直接放在本地，所以访问速度得到了保证。 对于图片方面，目前是将宝可梦的图片放到了腾讯云的存储对象中，缩略图本身每张的大小并不是很大，所以没有用雪碧图，可能下一个版本会进行改进。准备在第二版当中继续提升性能，然后加入一些其他功能，比方说进化关系和能力值计算等。 也欢迎其他感兴趣的人一起加入或者提些意见，毕竟一个人做难免有些想法并不是最完美的~ (因为有appID所以不能开源)关于Lap这个hexo theme 最近就准备继续更新，因为也是自己用心弄的一个项目，肯定不能荒废掉，会一直坚持的！]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于切换到https]]></title>
    <url>%2F2018%2F02%2F07%2F%E5%85%B3%E4%BA%8E%E5%88%87%E6%8D%A2%E5%88%B0https%2F</url>
    <content type="text"><![CDATA[起因其实不切https也没什么性能上的问题，就是想把chrome上的安全绿锁头显示出来；从另一方面讲，还能减少一些http劫持(这个其实深层次的我也没研究过，包括DNS劫持之类的…)和运营商劫持，切到https后，看上去好像是减少了一些被劫持的几率。 具体操作因为是静态资源，也不想买国内的服务器(有国外的vps了)，所以就用github page，至于简单的如何配置hexo blog这里就不陈述了，反正百度一大把。 因为github page不能上传ssl证书，所以就用CDN实现反向代理，原理基本上就是利用CDN服务器反向代理到github page 因为CDN服务器是提供https服务的，所以最终自己的域名也会变成https。 这里我用的是CloudFlare： 注册一个账号并登陆 添加一个站点把自定义的域名配入,等扫描，扫描结束点击继续 DNS项配入，把自己的域名和github page的ip地址配入到DNS解析当中，具体就是创建一个CNAME类型，这里填写的是你原来github page的域名， 然后再创建两个类型是A，name是自己的域名，值是github的ip 192.30.252.153和192.30.252.154，类似于底下这张图： 然后把下面的DNS服务器里的地址复制好，将自己购买的域名的服务器下的DNS改成这个 让在Crypto选项处设置ssl为flexible 在page rules中设置路由规则。然后设置两条规则Always use https一条url是http://域名/ ，另一条是http://域名/*，这样就能开启强制https 都配置好在12小时以内就会生效，然后博客就正式切到https了]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[edit-highlight]]></title>
    <url>%2F2018%2F02%2F01%2Fedit-highlight%2F</url>
    <content type="text"><![CDATA[把Lap的highlight风格做了一次大的调整，改成了自己最喜欢的atom-one-dark，只不过ES6的语法好像暂时没办法高亮，因为hexo内置hl渲染方法渲染出来的dom节点根本没办法对ES6部分写样式。下面的是效果的展示，暂时也算满意了，可能以后还会进行一次调整。 123456789101112131415161718function $initHighlight(block, cls) &#123; try &#123; if (cls.search(/\bno\-highlight\b/) != -1) return process(block, true, 0x0F) + ` class="$&#123;cls&#125;"`; &#125; catch (e) &#123; /* handle exception */ &#125; for (var i = 0 / 2; i &lt; classes.length; i++) &#123; if (checkCondition(classes[i]) === undefined) console.log('undefined'); &#125;&#125;const sss = () =&gt; &#123;&#125;let a = 1export $initHighlight; 12345678910111213&lt;!DOCTYPE html&gt;&lt;title&gt;Title&lt;/title&gt;&lt;style&gt;body &#123;width: 500px;&#125;&lt;/style&gt;&lt;script type="application/javascript"&gt; function $init() &#123;return true;&#125;&lt;/script&gt;&lt;body&gt; &lt;p checked class="title" id='title'&gt;Title&lt;/p&gt; &lt;!-- here goes the rest of the page --&gt;&lt;/body&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[日常随笔]]></title>
    <url>%2F2018%2F01%2F28%2Fdaily-1%2F</url>
    <content type="text"><![CDATA[关于Lap这个theme现在还差个人介绍模块和article模块没有进行优化，其他的可能弄完以后暂时先不更新了不过该有的功能和统计的东西肯定是会一点一点全部完成的 对于disqus，虽然看了一下其他人分享的如何去走代理设置让国内也可以访问，但我觉得这个办法还是不太好，既然无法成为一种更加通用可配置的方案，那就暂时不考虑了，也不是每个人都会去买一个vps进行配置，索性接这样弄: 3s访问不到就提示需要翻墙才可以进行评论。。 我觉得这样的处理方法比较通用吧。 近期安排最近可能要继续开始加班了，毕竟年末，所以写开源和学习的自由时间可能不是很多，但我想起我有一部分文章放在了简书，所以我决定先搬运一波，然后在把自己学Graphql的一些东西稍微写写，最近就是graphql了，别的也没空看了，等年后吧~ 最近一到周末就沉迷pokemon revolution不能自拔，可能要写一篇去安利一发了，毕竟是很多90后乃至80后满满的回忆~（更重要的是能和老外尬英文、PY）]]></content>
      <categories>
        <category>个人小纪</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于最近的折腾]]></title>
    <url>%2F2018%2F01%2F18%2F%E5%85%B3%E4%BA%8E%E6%9C%80%E8%BF%91%E7%9A%84%E6%8A%98%E8%85%BE%2F</url>
    <content type="text"><![CDATA[其实一直想用这个写博客的，但是出现过一次问题： 我在win上面提交都是正常的，但是把项目搞到mac上之后提交就出现了bug，研究了半天也没找到完美解决的办法，这才自己去搭建了一个自己的博客。。 自己是在搬瓦工的vps上搭建的，采用的是golang的gin + React + Nextjs ，总体上倒是没什么问题，唯一的问题就是cdn解析过慢，毕竟有墙的因素在，感觉身在国内确实也没法避免这个问题，性能上反正我自己是忍受不了了，于是还是回来写这个。。 不过好像也更新了很多，可能好多的插件什么的也不能用了，准备近期好好弄一下，把bug都解决掉。]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ng-router]]></title>
    <url>%2F2017%2F09%2F15%2Fng-router%2F</url>
    <content type="text"><![CDATA[ng-routerng-router可以把angular1变成一个spa应用，在页面上的原理就是渲染了不同的controller来实现不同的路由，具体实例代码如下：1234567891011121314151617181920212223242526272829303132&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;AngularJS 路由实例 - 菜鸟教程&lt;/title&gt; &lt;/head&gt; &lt;body ng-app='routingDemoApp'&gt; &lt;h2&gt;AngularJS 路由应用&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#/"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#/computers"&gt;电脑&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#/printers"&gt;打印机&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#/blabla"&gt;其他&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div ng-view&gt;&lt;/div&gt; &lt;script src="http://apps.bdimg.com/libs/angular.js/1.4.6/angular.min.js"&gt;&lt;/script&gt; &lt;script src="http://apps.bdimg.com/libs/angular-route/1.3.13/angular-route.js"&gt;&lt;/script&gt; &lt;script&gt; angular.module('routingDemoApp',['ngRoute']) .config(['$routeProvider', function($routeProvider)&#123; $routeProvider .when('/',&#123;template:'这是首页页面'&#125;) .when('/computers',&#123;template:'这是电脑分类页面'&#125;) .when('/printers',&#123;template:'这是打印机页面'&#125;) .otherwise(&#123;redirectTo:'/'&#125;); &#125;]); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 首先，载入了实现路由的js文件：angular-route.js； 然后，包含了ngRoute模块作为主应用模块的依赖模块。1angular.module('routingDemoApp',['ngRoute']) 使用ngView指令1&lt;div ng-view&gt;&lt;/div&gt; 该div内html会根据路由的变化来变化。 然后配置$routeProvider, 用于定义我们的路由规则 1234567module.config(['$routeProvider', function($routeProvider)&#123; $routeProvider .when('/',&#123;template:'这是首页页面'&#125;) .when('/computers',&#123;template:'这是电脑分类页面'&#125;) .when('/printers',&#123;template:'这是打印机页面'&#125;) .otherwise(&#123;redirectTo:'/'&#125;);&#125;]);]]></content>
      <categories>
        <category>AngularJS</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ngapi]]></title>
    <url>%2F2017%2F09%2F15%2Fngapi%2F</url>
    <content type="text"><![CDATA[ngApiangular JS全局API用于执行常见任务的JS函数集合，如： 比较对象 迭代对象 转换对象简单的说就是将一些工作中常用的方法封装到了angular.prototype上了，下面有几个典型的： angular.lowercase() - 转换字符为小写 angular.uppercase() - 转换字符为大写 angular.isString() - 判断是否是字符串 angular.isNumber() - 判断是否是数字 例子： 地址]]></content>
      <categories>
        <category>AngularJS</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ng过滤器]]></title>
    <url>%2F2017%2F09%2F14%2Fng%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[ng过滤器所有的例子会写在这里：例子 首先学习一下ng1的过滤器的一个基本写法： 一个过滤器，不带参数的情况1&#123;&#123;expression | filter&#125;&#125; 一个过滤器，带参数的情况1&#123;&#123;expression | filter:arguments&#125;&#125; 一个过滤器，带多个参数的情况1&#123;&#123;expression | filter: arg1: arg2: ...&#125;&#125; 多个过滤器，不带参数的情况1&#123;&#123;expression | filter1 | filter2 | ...&#125;&#125; 先学习自定义的，现找出来10个： 1. currency顾名思义，用于将数字转换为货币的默认的话，是将数字转化成了当前使用语言环境的符号当然也可以设置自定义符号，格式：1&#123;&#123; currency_expression | currency : symbol : fractionSize&#125;&#125; 其中symbol代表你要自定义的货币符号，fractionSize代表小数位的取舍量 2. date根据要求将时间转换成字符串，开发当中经常用到，格式化的字符串可以由以下原件组成： ‘yyyy’: 年份用4位数字表示(e.g. AD 1 =&gt; 0001, AD 2010 =&gt; 2010) ‘yy’: 年份用2位数字表示, 补全0 (00-99). (e.g. AD 2001 =&gt; 01, AD 2010 =&gt; 10) ‘y’: 年份用最少位数字表示, e.g. (AD 1 =&gt; 1, AD 199 =&gt; 199) ‘MMMM’: 月份 (January-December) ‘MMM’: 月份 (Jan-Dec) ‘MM’: 月份, 补全0 (01-12) ‘M’: 月份 (1-12) ‘dd’: 日期, 补全0 (01-31) ‘d’: 日期 (1-31) ‘EEEE’: 星期,(Sunday-Saturday) ‘EEE’: 星期, (Sun-Sat) ‘HH’: 小时, 补全0 (00-23) ‘H’: 补全0 (0-23) ‘hh’: AM/PM 表示的小时, 补全0 (01-12) ‘h’: AM/PM 表示的小时, (1-12) ‘mm’: 分钟, 补全0 (00-59) ‘m’: 分钟 (0-59) ‘ss’: 秒, 补全0 (00-59) ‘s’: 秒 (0-59) ‘sss’: 毫秒, 补全0 (000-999) ‘a’: AM/PM 标记 ‘Z’: 用4位表示时区的偏移 (-1200-+1200) ‘ww’: 周数, 补全0 (00-53). 01周是每年的包含第一个周四的周 ‘w’: Week of year (0-53). 01周是每年的包含第一个周四的周 ‘G’, ‘GG’, ‘GGG’: 时代的简写字符串 (e.g. ‘AD’) ‘GGGG’: 时代的完整字符串 (e.g. ‘Anno Domini’) 格式字符串还可以是下列预定义的本地化的格式之一: ‘medium’: en_US 地区的形式，等同于 ‘MMM d, y h:mm:ss a’ (e.g. Sep 3, 2010 12:05:08 PM) ‘short’: en_US 地区的形式，等同于 ‘M/d/yy h:mm a’ (e.g. 9/3/10 12:05 PM) ‘fullDate’: en_US 地区的形式，等同于 ‘EEEE, MMMM d, y’ (e.g. Friday, September 3, 2010) ‘longDate’: en_US 地区的形式，等同于 ‘MMMM d, y’ (e.g. September 3, 2010) ‘mediumDate’: en_US 地区的形式，等同于 ‘MMM d, y’ (e.g. Sep 3, 2010) ‘shortDate’: en_US 地区的形式，等同于 ‘M/d/yy’ (e.g. 9/3/10) ‘mediumTime’: en_US 地区的形式，等同于 ‘h:mm:ss a’ (e.g. 12:05:08 PM) ‘shortTime’: en_US 地区的形式，等同于 ‘h:mm a’ (e.g. 12:05 PM) 格式字符串可以包含文字。但是需要使用 ‘ 包裹进行转义 (e.g. “h ‘in the morning’”).如果想使用单引号,则需要转义 - 举个例子, 在一行里有两个单引号 (e.g. “h ‘o’’clock’”).]]></content>
      <categories>
        <category>AngularJS</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ng1学习]]></title>
    <url>%2F2017%2F09%2F13%2Fangular1%2F</url>
    <content type="text"><![CDATA[ng1学习开始搞新项目，采用hybird开发，web层用ng1搞，呵呵。这下不得不搞ng了。。。 这样下来也算是前端三大框架都玩了一遍（不过也就vue算是熟练） 先挖个坑，慢慢开始重新写（前面把日志都写到有道云笔记了。准备一点一点搬过来重构博客了）]]></content>
      <categories>
        <category>AngularJS</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于es7bind语法的小纪]]></title>
    <url>%2F2017%2F04%2F21%2Fes7bind%E8%AF%AD%E6%B3%95%E7%9A%84%E5%B0%8F%E7%BA%AA%2F</url>
    <content type="text"><![CDATA[有关es7 function bind syntax的东西因为群里有大佬以前提到过，但是因为自己太菜了根本无法理解，所以就去学习了一下。。 概念所谓的function bind syntax ，其实就是一个绑定的语法糖，就和箭头函数是类似的（箭头函数是声明函数时绑定this的语法糖，这里就有个坑，用箭头函数声明的方法就不能再使用::去绑定了，不会起作用。。） 作用简单来说::有两种作用： 当::出现在一个对象名的签名，且对象名后面紧跟着一个它的方法名的时候，作用就是把这个对象绑定为这个方法的this 12345678let obj = &#123; method() &#123; console.log(this) &#125;&#125;::obj.method//等同于obj.method.bind(obj) 当::出现在对象和方法名之间的时候，将这个对象绑定为这个方法的this,当然，因为这个绑定后还是一个函数，所以也可以直接调用 123456789101112131415let obj = &#123; foo: 'bar'&#125;function method() &#123; console.log(this.foo)&#125;obj::method()//等同于method.call(obj)()obj::method//等同于method.bind(obj)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Ecmascript7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学RxJS]]></title>
    <url>%2F2017%2F03%2F20%2F%E5%88%9D%E5%AD%A6RxJS%2F</url>
    <content type="text"><![CDATA[初学Rxjs概念Rxjs 是一个通过使用可观察序列来构建异步和基于事件的程oberservable序的库，可以吧它当成一个针对于事件的lodash Rxjs就是JavaScript的响应式扩展，响应式的思路就是把随时间不断变化的数据、状态、事件等等转化成可被观察的序列(observable sequence),然后订阅序列中那些observable对象的变化，一旦变化，就会执行事先安排好的各种转换和操作 四个生命周期 创建：创建一个observable，返回一个被观察的序列源实例 订阅：通过序列源实例可以订阅序列发射新数据变更时的响应方法（回调方法） 执行：响应的动作就是执行 销毁：通过序列源实例可以销毁，而当订阅方法发生错误时也会自动销毁 剖析可观察对象使用Rx.Observable.create或一个能产生可观察对象的操作符来创造一个可观察对象，使用一个观察者订阅他，执行然后给观察者发送next/error/complete的通知，他们的执行可能会被disposed（处理）。这四个方面均被编码进可观察对象的实例当中。 核心的可观察对象的概念 Creating Observables 创建 Subscribing Obserables 订阅 Executing the Observable 执行 Disposing Observables 处理 Creating ObservablesRx.Observable.create 用来创建一个可观察对象 ，是可观察对象构造函数的别名，它接受一个参数（订阅的 fnuction） 12345var observable = Rx.Observable.create(function subscribe(observer) &#123; var id = setInterval(() =&gt; &#123; observer.next('hi') &#125;, 1000);&#125;); Subscribing Obserables一个可观察对象可以被订阅 1observable.subscribe(x =&gt; console.log(x)); 这里的subscribe和上面create的subscribe是不一样的，但是你可以在概念上将他们等价，上面写成一个匿名函数也是可以的12345var observable = Rx.Observable.create(observer =&gt; &#123; var id = setInterval(() =&gt; &#123; observer.next('hi') &#125;, 1000);&#125;); 订阅一个可观察对象就像是调用一个函数，在数据将被发送的地方提供回调 完全不同于addEventListener/removeEventListener事件句柄API,使用observervable.subscribe，给定的观察者并没有作为一个监听者被注册 订阅数启动可观察对象执行和发送值或者事件给观察者的简单方式 Executing the Observable执行可观察对象就是在创建时里面的匿名函数做的事情，一个仅在观察者订阅时发生的惰性计算，执行随时间产生多个值，以同步或者异步的方式 下面是observervable对象可以发送的三种类型的值： next 发送一个数字/字符串/对象等等 error 发送一个js错误或者异常 complete 不发送值next可以在可观察对象执行期间发生多次，而error和complete只能在执行期间发生一次，但仅会执行二者之中的一个 一个可观察对象的执行期间，零个到无穷多个next通知被发送。如果Error或者Complete通知一旦被发送，此后将不再发送任何值。 一个好的使用方式就是使用try catch语句去包裹通知语句，如果捕获了异常就会发送一个错误通知 12345678910var observable = Rx.Observable.create(function subscribe(observer) &#123;try &#123;observer.next(1);observer.next(2);observer.next(3);observer.complete();&#125; catch (err) &#123;observer.error(err); // delivers an error if it caught one&#125;&#125;); Disposing Observables处理可观察对象的执行： 由于可观察对象的执行可能是无限的(无数个next)，而对于观察者来说却往往需要在有限的时间内终止执行，因此需要一个api来取消执行。因为每次的执行仅仅服务于一个观察者，一旦观察者听得接收数据，他就不得不通过一个方式去终止执行，从而避免浪费大量的计算性能和内存资源 这里observable.subscribe被调用返回了一个对象： subscription这个对象表示了正在进行的执行： 1var subscription = observable.subscribe(x =&gt; console.log(x)); 在这里使用subscription.unsubscribe()就可以取消你正在进行的执行 observer观察者观察者就是可观察对象所发送数据的消费者，简单说就是一组回调函数，分别对应一种被可观察对象发送的通知的类型：next、error和complete 观察者不过是三个回调函数组成的对象，每个回调函数分别对应可观察对象的通知类型 123456var observer=&#123;next:x=&gt;console.log('Observer got a next value: ' + x),error: err =&gt; console.error('Observer got an error: ' + err),complete: () =&gt; console.log('Observer got a complete notification')&#125;observable.subscribe(observer) 当订阅一个可观察对象，你仅仅提供回调来作为参数就够了，并不需要完整的观察者对象 在observable.subscribe内部，他讲使用第一个回调参数作为next的处理句柄创建一个观察者对象，也可以通过将三个函数作为参数提供三种回调 12345observable.subscribe( x =&gt; console.log('Observer got a next value: ' + x), err =&gt; console.error('Observer got an error: ' + err), () =&gt; console.log('Observer got a complete notification')); Subject主题Subject是允许值被多播到多个观察者的一种特殊的observable Subject就是一个可观察对象，只不过可以被多播至多个观察者。同时Subject也类似于eventemitter：维护着众多事件监听器的注册表 每一个Subject及时一个可观察对象，又是一个观察者对象，也就是说，它既可以拥有next、error、complete方法，又可以去subscribe它 观察者： 有next、error等方法 可观察对象： 可以被订阅demo： 1234567891011var subject = new Rx.Subject();subject.subscribe(&#123; next: (v) =&gt; console.log('observerA: ' + v)&#125;);subject.subscribe(&#123; next: (v) =&gt; console.log('observerB: ' + v)&#125;);subject.next(1);subject.next(2); 输出效果如下：1234observerA: 1observerB: 1observerA: 2observerB: 2 多播的可观察对象一个多播的可观察对象可以通过多个订阅者的订阅去传递通知，而普通的单播可观察对象不可以12345678910var source=Rx.Observable.from([1,2,3]);var subject=new Rx.Subject();var multicasted=source.multicast(subject);multicasted.subscribe(&#123; next:(v)=&gt;console.log('observerA:' +v);&#125;);multicasted.subscribe(&#123; next: (v) =&gt; console.log('observerB: ' + v)&#125;);multicasted.connect(); multicast方法返回一个看起来像普通的可观察对象的可观察对象，但是却有着和subject一样的行为，multicast返回一个connectableobservable，他是一个具有connect方法的observable connect方法对于觉得何时开始分享可观察对象的执行时非常重要的，在source下面有source.subscribe（subject），connect（）返回一个Subscription，你可以取消订阅，以取消共享的Observable执行。]]></content>
  </entry>
  <entry>
    <title><![CDATA[redux中间件-reduxsaga学习]]></title>
    <url>%2F2017%2F03%2F11%2Fredux%E4%B8%AD%E9%97%B4%E4%BB%B6-reduxsaga%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[redux-saga考虑到后期项目可能需要去异步对redux进行一些操作，看了react的生态圈，发现这个中间件比较火，就想学习一下，在这里做个简单的记录]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echarts学习]]></title>
    <url>%2F2017%2F03%2F09%2Fecharts%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[echarts api学习因为暂时项目当中使用的是echarts-for-react插件，所以暂时先不考虑了解echarts原生对象的一些方法，先从配置项开始学习。 首先是初始化一个echarts对象，然后这个对象去调用echarts的setOption方法，配置展示的信息。 setOption用来写echarts图表的配置信息 title标题组件，包含主标题和副标题12345678910111213141516171819202122232425262728293031323334353637383940title: &#123; show: //是否显示标题组件 默认是true text://主标题文本 link: //主标题的超文本链接，也可以用在react的路由跳转 target: //指定打开超链接的方式 默认是新窗口 textStyle: &#123; color: // 主标题颜色 fontWeight: //主标题文字字体粗细 fontFamily: // 主标题文字字体 fontSize: //主标题文字字体大小 &#125; textAligin: //标题文本水平对齐方式 textBaseline: //标题文本垂直对齐方式 subtext: //副标题文本 副标题也有主标题同样的配置，这里就不记录了 sublink: //富文本超链接 &#125;,//api太多啦，也不记载这么多了，具体的自己去官网看吧，自己就记录一些第一层的配置信息legend: //图例组件，展现了不同系列的标记(symbol)，颜色和名字。可以通过点击图例控制哪些系列不显示grid: //直角坐标系内绘图网格，单个grid内最多可以放置上下两个x轴，左右两个y轴。可以在网格上绘制折线图、柱状图、散点图(气泡图)，在echarts3当中可以存在任意多个grid组件xAxis: // 直角坐标系grid中的x轴，一般情况下grid组件最多只能放左右两个x轴，多于两个x轴需要通过配置offset防止同个位置多个x轴的重叠yAxis: //直角坐标系 grid 中的 y 轴，一般情况下单个 grid 组件最多只能放左右两个 y 轴，多于两个 y 轴需要通过配置 offset 属性防止同个位置多个 Y 轴的重叠。polar: // 极坐标系，可以用于散点图和折线图，每个极坐标拥有一个角度轴和一个半径轴radiusAxis: //极坐标系的径向轴angleAxis: //极坐标系的角度轴radar : // 雷达坐标系组件dataZoom: // 用于区域缩放，从而能自由关注细节的数据信息，或者概览数据整体，或者去除离群点的影响tooltip: //提示框组件]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux学习(3)]]></title>
    <url>%2F2017%2F03%2F04%2Fredux%E5%AD%A6%E4%B9%A0-3%2F</url>
    <content type="text"><![CDATA[redux学习(三)基本快把react-redux都看完了，还差最后的几部。 &lt;Provider&gt;组件connect方法生成容器组件后，需要让容器组件拿到state对象，才能生成ui组件的参数 一种解决方法就是将state对象作为参数，传入容器组件。但是，这样做比较麻烦，尤其是容器组件可能在很深的层级，一级级将state传下去就很麻烦 使用了provider组件后，可以让容器组件拿到state12345678910111213import &#123; Provider &#125; from 'react-redux'import &#123; createStore &#125; from 'redux'import todoApp from './reducers'import App from './components/App'let store = createStore(todoApp);render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')) 上面的例子当中，使用provider组件在根组件外面包了一层，这样一来，app的所有组件就默认可以拿到state了]]></content>
      <categories>
        <category>react</category>
        <category>redux</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux学习2]]></title>
    <url>%2F2017%2F03%2F03%2Fredux%E5%AD%A6%E4%B9%A02%2F</url>
    <content type="text"><![CDATA[react-redux学习react-redux是一个专门用于在react项目中使用redux的一个库，而且还有一定的规范和写法的推荐。还有额外的api需要去学习。 组件规范ui组件首先react-redux将所有的组件分成了两大类：ui组件和容器组件 UI组件只负责样式和ui 所有数据都由props来传递 不使用任何的redux 容器组件 管理所有的 使用redux connect() react-redux提供了一个connect方法 ，用来从ui组件生成一个容器组件 但是，如果只是简单的进行了对UI组件的包装的，并没有太多的作用，为了定义业务逻辑，需要给出下面两方面的信息。 输入逻辑: 外部的数据(即state对象)如何转换为UI组件的参数 输出逻辑: 用户发出的动作如何变为Action对象，从UI组件传出去 完整的API如下： 123456import &#123; connect &#125; from 'react-redux'const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps)(TodoList) 上面两个参数就是对应了输入逻辑和输出逻辑 前者负责输入逻辑，即将state映射到ui组件的参数(props)后者负责输出逻辑，将用户对ui组件的操作映射成action mapStateToProps()mapStateToProps 是一个函数。它的作用就是像它的名字那样，建立一个从(外部的)state对象到 (UI组件的) props对象的映射关系 看一个count的例子: 12345const mapStateToProps = (state) =&gt; &#123; return &#123; counter: state.counter &#125;&#125; 这里的mapStateToProps 是一个fun ，它接收一个state作为参数，并且返回了一个obj，这个obj有一个counter属性，代表了ui组件当中的同名参数，然后这里也可以自己自定义一个fun去计算返回一个obj mapStateToProps会订阅store，每当你的state更新的时候，就会自动执行，重新计算ui组件的参数，从而触发ui组件的重新渲染。而不需要使用subscribe这个方法了 除了可以传一个参数state以外，还可以使用第二个参数，代表容器组件的props对象然后容器组件的参数发生变化，也会引发UI组件的重新渲染 mapDispatchToProps()mapDispatchToProps是connect的第二个参数，用来建立UI组件的参数到store.dispatch方法的映射，定义了ui组件发出action的方法 如果mapDispatchToProps是一个对象，它的每个键名也就是对应ui组件的同名参数，数值应该是一个函数，会被当做Action creator，返回的Action 会由redux自动发出，eg: 123456const mapDispatchToProps = &#123; onClick: (filter) =&gt; &#123; type: 'SET_VISIBILITY_FILTER', filter: filter &#125;;&#125; 上面的就是一个例子，上面的mapDispatchToProps这个对象当中的onClick这个键值其实就是一个UI组件的props]]></content>
      <categories>
        <category>react</category>
        <category>redux</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux学习(1)]]></title>
    <url>%2F2017%2F02%2F27%2Fredux%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Redux学习因为我最先掌握的是vuex，反过头来去看学习成本相对较高的redux，可能效果会好一点。 redux是JavaScript状态容器，提供了可预测化的状态管理 redux由flux演变而来，但受elm的启发，避开了flux的复杂性 核心应用当中的所有state都是以一个对象树的形式存储在一个一个单一的store当中，唯一改变state的办法就是触发action，一个描述发生什么的对象，为了描述action如何改变state树，你需要去编写reducers 三大原则redux可以用这三个基本原则来描述： 1.单一数据源整个应用的state被存储在一棵 object tree中，并且这个object tree只存在于唯一一个store中。 2.state是只读的唯一改变state的方法就是触发action，action是一个用于描述已发生事件的普通对象 3.使用纯函数来执行修改为了描述action如何改变state tree ，你需要编写reducers。 reducer只是一些纯函数，它接收先前的state和action，并返回新的state。刚开始你可以只有一个reducer，随着应用的变大，你可以把它拆成多个小的reducers，分别独立操作state tree的不同部分 redux的一般写法层次: 首先一般的redux要分为component和reducer两部分 component当中只负责ui的设计，里面所有的方法和数据全部写成props，暴露给上层去调用 reducer负责接收state和action两个参数，然后根据action的type属性进行不同的操作，返回不同的state 最终使用redux当中的一个叫做createStore方法来生成store，参数就是上面的reducer 然后在给子component传props的时候，调用store当中的dispatch方法来改变state，参数需要传action(因为state的初始值已经给出，不需要传) 但是这种普通的redux写法只能运用于特别简单的应用当中，如果要用到一个大型的react项目当中配合react-router一起使用，就要用到react-redux了]]></content>
      <categories>
        <category>react</category>
        <category>redux</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-router学习(2)]]></title>
    <url>%2F2017%2F02%2F27%2Freact-router-2%2F</url>
    <content type="text"><![CDATA[react router学习(2)路由匹配原理路由有三个属性来决定是否匹配一个url 嵌套关系 它的路径语法 它的优先级 嵌套关系React Router 使用路由嵌套的概念来让你定义 view 的嵌套集合，当一个给定的 URL 被调用时，整个集合中（命中的部分）都会被渲染。嵌套路由被描述成一种树形结构。 React Router 会深度优先遍历整个路由配置来寻找一个与给定的 URL 相匹配的路由。 它的路径语法 :paramName 匹配一段位于/、?、#之后的url，命中的部分将被作为参数 () 在它内部的内容被认为是可选的 匹配任意字符(非贪婪的)直到命中下一个字符或者整个url的末尾，并创建一个splat参数 它的优先级路由算法会根据定义的顺序自顶向下匹配路由。因此，当你拥有两个兄弟路由节点配置时，你必须确认前一个路由不会匹配后一个路由中的路径。 例如，千万不要这么做： 12&lt;Route path="/comments" ... /&gt;&lt;Redirect from="/comments" ... /&gt; HistoryHistory用来去监听浏览器地址栏的变化，并解析这个url转化为location对象，然后router使用它去匹配路由，然后渲染相应的组件 History的模式常用的有三种，当然你也可以去自定义 browserHistory hashHistory createMemoryHistory 用法： 你先从react-router当中引用他们 1import &#123; browserHistory &#125; from 'react-router' 然后将它们传递给&lt;Router&gt;1234render( &lt;Router history=&#123;browserHistory&#125; routes=&#123;routes&#125; /&gt;, document.getElementById('app')) browserHistorybrowserHistory是用的比较多的一种模式 它使用浏览器中的historyAPI用于处理URL，创建一个真实的url 看到这里正好还解决了我一个肯长时间百思不得其解的问题，就是我vue写的项目打包放到Nginx服务器上面后，路由匹配会报错，然后按照这里给Nginx反向代理的方法重新配置了服务器，发现错误就解决了。 hashHistoryhashHistory 使用url中的hash(#)部分去创建形如 example.com/#/some/path 的路由。但由于有一个#号 所以看起来会比较丑，所以不建议线上使用 createMemoryHistoryMemory History不会在地址栏被操作或读取。 它非常适合测试和其他的渲染环境(React Native) 和另外两种history的一点不同的是你必须创建它，这种方式便于测试 1const history = createMemoryHistory(location) Index Links除了路由有默认的 link也有，如果你使用了&lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt;,它会一直处于激活状态，因为所以的url的开头都是/。这个确实是个问题，因为我们仅仅希望在home被渲染后，激发并链接到它 如果需要在home路由被渲染后才激活 就用&lt;IndexLink to=&quot;/&quot;&gt;Home&lt;/IndexLink&gt; 就先记这么多，以后遇到坑在补]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-router学习(1)]]></title>
    <url>%2F2017%2F02%2F27%2Freact-router%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[react-router学习关于配置什么的 请自行移至百度，下面就记录一下如何使用react-router 有关react-router的内容都是从这里学习和摘抄的： react中文文档 先写一个简单的例子来解释一下如何编写路由配置:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import React from 'react';import &#123; Router, Route, Link &#125; from 'react-router'const App = React.createClass(&#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;App&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to="/about"&gt;About&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to="/inbox"&gt;Inbox&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &#123;this.props.children&#125; &lt;/div&gt; ) &#125;&#125;)const About = React.createClass(&#123; render() &#123; return &lt;h3&gt;About&lt;/h3&gt; &#125;&#125;)const Inbox = React.createClass(&#123; render() &#123; return ( &lt;div&gt; &lt;h2&gt;Inbox&lt;/h2&gt; &#123;this.props.children || "Welcome to your Inbox"&#125; &lt;/div&gt; ) &#125;&#125;)const Message = React.createClass(&#123; render() &#123; return &lt;h3&gt;Message &#123;this.props.params.id&#125;&lt;/h3&gt; &#125;&#125;)React.render(( &lt;Router&gt; &lt;Route path="/" component=&#123;App&#125;&gt; &lt;Route path="about" component=&#123;About&#125; /&gt; &lt;Route path="inbox" component=&#123;Inbox&#125;&gt; &lt;Route path="messages/:id" component=&#123;Message&#125; /&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;/Router&gt;), document.body) 这里，最下面的render就是路由配置的一个具体的格式，其中主路由 &#39;/&#39; 是匹配的 App这个组件紧接着 about 和 inbox 是 App 的子组件 他们显示的位置就是 this.props.children的位置他们会在路由匹配成功后显示在对应的位置上面然后是inbox里面的又一个子路由，这个路由还待了一个参数id，会跟着路由传过来，就是说 我们匹配到/inbox/messages/xxx 的时候 message这个组件就会被渲染出来，而且对应的this.props.params.id也就是xxx 添加首页仅仅这样写是不够的，比方说我没有给出子路由的时候this.props.children就是undefined这个时候我们就应该加入一个默认的路由去渲染，我们可以使用IndexRouter 来设置默认的页面 1234567891011121314151617181920import &#123; IndexRoute &#125; from 'react-router'const Dashboard = React.createClass(&#123; render() &#123; return &lt;div&gt;Welcome to the app!&lt;/div&gt; &#125;&#125;)React.render(( &lt;Router&gt; &lt;Route path="/" component=&#123;App&#125;&gt; &#123;/* 当 url 为/时渲染 Dashboard */&#125; &lt;IndexRoute component=&#123;Dashboard&#125; /&gt; &lt;Route path="about" component=&#123;About&#125; /&gt; &lt;Route path="inbox" component=&#123;Inbox&#125;&gt; &lt;Route path="messages/:id" component=&#123;Message&#125; /&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;/Router&gt;), document.body) 这样的话 当我们的url是/时，我们渲染的子路由 this.props.children的位置就是Dashboard 这个路由 如果我们想要将 /inbox 从 /inbox/messages/:id中去除，并且还能够让 Message 嵌套在 App -&gt; Inbox 中渲染，那会非常赞。绝对路径可以让我们做到这一点。 123456789101112React.render(( &lt;Router&gt; &lt;Route path="/" component=&#123;App&#125;&gt; &lt;IndexRoute component=&#123;Dashboard&#125; /&gt; &lt;Route path="about" component=&#123;About&#125; /&gt; &lt;Route path="inbox" component=&#123;Inbox&#125;&gt; &#123;/* 使用 /messages/:id 替换 messages/:id */&#125; &lt;Route path="/messages/:id" component=&#123;Message&#125; /&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;/Router&gt;), document.body) 这样，我们的绝对路径就写好了，匹配/messages/:id 会依次渲染 App -&gt; Inbox -&gt; Message 但是，这时候又有了新的问题,当我们访问/inbox/messages/5的时候 我们就会看到错误，这个的解决办法就是路由的重定向，我们使用&lt;Redirect&gt;来使这个url重新工作 12345678910111213141516import &#123; Redirect &#125; from 'react-router'React.render(( &lt;Router&gt; &lt;Route path="/" component=&#123;App&#125;&gt; &lt;IndexRoute component=&#123;Dashboard&#125; /&gt; &lt;Route path="about" component=&#123;About&#125; /&gt; &lt;Route path="inbox" component=&#123;Inbox&#125;&gt; &lt;Route path="/messages/:id" component=&#123;Message&#125; /&gt; &#123;/* 跳转 /inbox/messages/:id 到 /messages/:id */&#125; &lt;Redirect from="messages/:id" to="/messages/:id" /&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;/Router&gt;), document.body) 这样的话，无论任何人点击/inbox/messages/5这个链接，它最终都会被重定向到/messages/5这个url上面 进入和离开的钩子Router 可以定义 onEnter 和 onLeave 两个钩子 ，这两个钩子会在页面跳转时触发，在验证权限的时候特别有用，在路由跳转过程当中，onLeav 钩子会在所有将离开的路由中触发，从最下层的子路由开始直到最外层父路由结束。然后onEnter 钩子会从最外层的父路由开始直到最下层子路由结束 继续我们上面的例子，如果一个用户点击链接，从 /messages/5 跳转到 /about，下面是这些 hook 的执行顺序： /messages/:id 的 onLeave /inbox 的 onLeave /about 的 onEnter]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[weex小记]]></title>
    <url>%2F2017%2F02%2F23%2Fweex%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[weex学习(一)上个学期学校实验周要求做一个项目，就考虑做个native端的，当时weex还不怎么稳定，看了半天网上的资料还是研究不出到底如何从构建到编译、打包，于是用了React Native，但是由于react本身学习成本的问题，做的并不精致，好多东西都没用进去。 在公司实习的这段时间，公司的新项目都使用vue，在这个3个多月的时间当中，基本学会了vue的整个概念和它的一些生态库，比方说vue-router和vuex，然后自己也了解了webpack打包编译的机制，还将nodejs后端的koa自己写到了一个个人的小项目里面： vue2-koa2的小demo感觉使用vue要比react清爽多了(关键还是学习成本低，上限还高)，现在看weex官方已经支持了vue语法编译，所以就学一下，准备毕设就拿这个开题。 关于weex和vue： Vue.js 是 Evan You 开发的渐进式 JavaScript 框架，在易用性、灵活性和性能等方面都非常优秀。开发者能够通过撰写 *.vue 文件，基于 &lt;template&gt;, &lt;style&gt;, &lt;script&gt; 快速构建组件化的 web 应用。Vue.js 在 2016 年 10 月正式发布了 2.0 版本，该版本加入了 Virtual-DOM 和预编译器的设计，使得该框架在运行时能够脱离 HTML 和 CSS 解析，只依赖 JavaScript；同时 Virtual-DOM 也使得 Vue 2.x 渲染成原生 UI 成为了可能。 weex就相对于react 和react native ，它就是vue的native版本，同时更加强大的是，它可以同时编译渲染web、android、ios三端。 目前 Weex 与 Vue 正在展开官方合作，并将 Vue 2.x 作为内置的前端框架，Vue 也因此具备了开发原生应用的能力。 关于起步由于我也是刚起步，不太能说明白，我是看的饿了么前端的一个妹子大神的教程才跟着一步一步配置出来的，链接在此: 快速开始weex之旅 Weex 入坑指南：手把手编译 Playground 我是直接把weex团队的weex-hacknews改了一下，就可以成为自己开发时候的一个基础架子了。然后可以自己去配置一下router、vuex等等的东西，然后编译调试打包。。。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件]]></title>
    <url>%2F2017%2F02%2F22%2Fvue%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[vue组件开发-轮播图今天自己写了一个轮播图的组件，在这里记录一下开发的具体流程 开始首先轮播图的一个关键就是定位和布局，如下图： 这里就是分几个部分： 图片 左右的按钮 底部的定位按钮 首先是图片，图片的写法是将所有的图片放在一个父级div当中，然后使用flex布局使他们处于同一排，然后图片的显示区域只有一个图片的大小，这样处于试图当中就只有一张图 接下来是左右的按钮，左右的按钮布局是用到了position:absolute 只要给父元素的div的样式当中加入相对布局,然后根据上下左右的定位和transform定位同时去控制，这样就保证了位置 底部的定位按钮的写法也是一样的 逻辑和功能的实现]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb存图片]]></title>
    <url>%2F2017%2F02%2F21%2Fmonggo%2F</url>
    <content type="text"><![CDATA[mongodb存储图片]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eggjs学习(一)]]></title>
    <url>%2F2017%2F02%2F16%2Feggjs-1%2F</url>
    <content type="text"><![CDATA[eggjs什么是eggjseggjs 是一个企业级的koa框架，相对于普通的koa，他有以下的一些优势： 深度框架定制 高度可扩展的插件机制 内置多进程管理 基于koa开发，性能优异 框架稳定，测试覆盖率高 渐进式开发 注意：是基于koa1的未完待续]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>koa</tag>
        <tag>eggjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[17年学习计划]]></title>
    <url>%2F2017%2F01%2F27%2F17%E5%B9%B4%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[16年成果今年总的来说已经达到了自己的目标，目前已经从一个只会一点前端发展到了前后端已经可以独立架构。目前所学会的技术如下： 前端： vue、react(尚未熟练)、react native、weex、各种库(vuex、vue-router、fetch、axios、lodash、d3)… 后端： express、koa2、mongodb… 17年计划实习2个多月，感觉自己最薄弱的就是有关移动端的样式、事件等，准备加大力度学习移动端所有知识和框架，比如：react native、weex等等，然后vue的服务端渲染也要彻底掌握，还有那个新出的vuessr框架nuxt，感觉这个东西会火，然后就是各种后端的东西，虽然说已经可以写一个完整的后端接口，但是还没有完善化，比方说加密方面和安全方面，都还是有待提高的，并且也不能仅限于nodejs，准备把php的thinkphp框架学起来，结合vue使用~]]></content>
      <categories>
        <category>个人小纪</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack2学习(五)]]></title>
    <url>%2F2017%2F01%2F22%2Fwebpack-5%2F</url>
    <content type="text"><![CDATA[模块热替换(Hot Module Replacement)模块热替换功能会在应用程序运行过程中替换、添加或删除模块，而无需重新加载页面。这使得你可以在独立模块变更后，无需刷新整个页面，就可以更新这些模块，极大地加速了开发时间。 站在app角度 app代码要求HMR runtime检查更新 HMR runtime(异步) 下载更新，然后通知app代码更新可用 app代码要求HMR runtime 应用更新]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack2学习(四)]]></title>
    <url>%2F2017%2F01%2F22%2Fwebpack-4%2F</url>
    <content type="text"><![CDATA[加载器(loaders)loader 是对应用程序中资源文件进行转换。它们是(运行在node.js中的) 函数，可以将资源文件作为参数的来源，然后返回新的资源文件例如，你可以使用loader告诉webpack加载css文件，或者将TypeScript转化为JavaScript loader特性 loader支持链式传递。能够对资源使用流水线(pipeline)。 loader链式按照时间先后顺序进行编译。loader链中的第一个loader返回值给下一个loader，并且在最后一个loader，webpack按照预期的JavaScript返回 loader可以是同步或者是异步函数。 loader运行在node.js中，并且能够执行任何可能的操作。 loader接受查询参数。用于loader间传递配置。 loader也能够使用 options对象进行配置 除了使用package.json的main属性，还可以将普通的npm模块导出为loader，做法是在package.json里定义一个loader字段 插件可以给loader带来更多的功能 loader能够产生额外的任意文件 loader通过(loader)预处理函数，为JavaScript生态系统提供了更多有利功能。用户现在可以更加灵活的引入细粒度逻辑，例如压缩、打包、语言翻译和其他 解析loaderloader解析类似于模块，loader模块需要导出一个函数，并且使用兼容node.js的JavaScript编写。在通常情况下，你可以使用npm管理loader，但是你也可以在应用程序中将loader作为文件去使用 引用loaderloader通常被命名为xxx-loader ，xxx是上下文的名称 eg： json-loader load的名称约定和优先搜索顺序，由webpack配置API中的resolveLoader、moduleTemplates定义 插件(plugins)webpack本身也是构建于同样的插件系统插件的目的在于解决loader无法实现的事情 解剖webpack插件是一个具有apply属性的JavaScript对象。apply属性会被webpack解析器(compiler)调用，并且可在整个编译生命周期(compilation lifecycle)访问。 ConsoleLogOnBuildWebpackPlugin.js1234567891011function ConsoleLogOnBuildWebpackPlugin() &#123;&#125;;ConsoleLogOnBuildWebpackPlugin.prototype.apply = function(compiler) &#123; compiler.plugin('run', function(compiler, callback) &#123; console.log("The webpack build process is starting!!!"); callback(); &#125;);&#125;;]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack2学习(三)]]></title>
    <url>%2F2017%2F01%2F22%2Fwebpack-3%2F</url>
    <content type="text"><![CDATA[输出outputoutput选项控制webpack如何向硬盘写入编译文件。注意，即使可以存在多个入口起点，但只指定一个输出配置 用法设置output属性，只需要在你的webpack配置简单的设置输出值： webpack.config.js12345const config = &#123; output: 'bundle.js'&#125;;module.exports = config; 下面是一些output的属性： output.filename指定硬盘每个输出文件的名称。在这里你不能指定绝对路径！ `output.path`选项规定了文件被写入硬盘的位置。 filename 仅用于命名每个文件。 单个入口123456789&#123; entry: './src/app.js', output: &#123; filename: 'bundle.js', path: __dirname + '/build' &#125;&#125;// 写入到硬盘：./build/bundle.js 多个入口 如果你的配置创建了多个chunk(例如使用多个入口点或使用类似CommonsChunkPlugin的插件)，你应该使用以下的替换方式来确保每个文件名都不重复。 [naem] 被chunk 的name 替换 [hash] 被编译(compilation) 的hash替换 [chunkhash] 被chunk 的hash 替换123456789101112&#123; entry: &#123; app: './src/app.js', search: './src/search.js' &#125;, output: &#123; filename: '[name].js', path: __dirname + '/build' &#125;&#125;// 写入到硬盘：./build/app.js, ./build/search.js output.hotUpdateChunkFilename热更新块(Hot Update Chunk)的文件名。 他们在output.path 目录中 [id] 被chunk的id替换 [hash] 被编译(compilation)的hash替换。 (最后一个hash存储在记录中) 默认值： &quot;[id].[hash].hot-update.js&quot; output.hotUpdateFunctionwebpack 用于异步加载(async loading)热更新块(hot update chunk)的 JSONP 函数。 ….还有好多就不详细记录了，具体去官网看吧，下面记录一个重点的： output.path以绝对路径作为导出目录(必选项) [hash] 被编译(compilation)的 hash 替换。 config.js1234output: &#123; path: "/home/proj/public/assets", publicPath: "/assets/"&#125; index.html123&lt;head&gt; &lt;link href="/assets/spinner.gif"/&gt;&lt;/head&gt; 接下来是一个更复杂的例子，来说明对资源使用 CDN 和 hash。 config.js1234output: &#123; path: "/home/proj/cdn/assets/[hash]", publicPath: "http://cdn.example.com/assets/[hash]/"&#125; output.sourceMapFilenamejavascript文件SourceMap的文件名。 它们在output.path目录中。 [file] 被JavaScript文件的文件名替换 [id] 被chunk的id替换 [hash] 被编译的(compilation)的hash替换 默认值：&quot;[file].map&quot;]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack2学习(二)]]></title>
    <url>%2F2017%2F01%2F22%2Fwebpack-2%2F</url>
    <content type="text"><![CDATA[entry入口起点单入口写法用法： entry： string|Array(string) webpack.config.js12345const config = &#123; entry: './path/to/my/entry/file.js'&#125;;module.exports = config; entry 属性的单入口语法： webpack.config.js1234567const config = &#123; entry:&#123; main:'./path/to/my/entry/file.js' &#125; &#125;;module.exports = config; 对象语法用法：entry: {[entryChunkName: string]: string|Array(string)} webpack.config.js 123456const config = &#123; entry: &#123; app: './src/app.js', vendors: './src/vendors.js' &#125;&#125;; 这是应用程序中定义入口的最可扩展的方式 webpack的可扩展配置是可重用的，并且可以与其他配置组合使用，这是一种流行的技术，用于将关注点从环境、构建目标、运行时中分离，然后使用专门的工具把它们合并在一起 常见场景入口分离 应用(app) 和 公共库(vendor)webpack.config.js 123456const config = &#123; entry: &#123; app: './src/app.js', vendors: './src/vendors.js' &#125;&#125;; 这告诉了我们webpack从app.js和vendors.js开始创建依赖图表。这些图表是完全分离的、互相独立的。在只有一个入口起点(不包括公共库)的单页面应用(spa)当中比较常见 此设置允许你使用CommonsChunkPlugin并从 app 包 提取 公共引用(vendor reference) 到 vendor 包，并把公共引用的部分替换为 webpack_require()调用。如果应用包中了没有公共代码，那么你可以在 webpack 中实现被称为 长效缓存的通用模式。 多页应用webpack.config.js 1234567const config = &#123; entry: &#123; pageOne: './src/pageOne/index.js', pageTwo: './src/pageTwo/index.js', pageThree: './src/pageThree/index.js' &#125;&#125;; 这里webpack 需要3个独立分离的依赖图表 在多页面应用中，服务器将为您获取一个新的html文档，页面重新加载新文档，并且资源被重新下载。然而，这给了我们独特的机会去做很多事： 使用 CommonsChunkPlugin 为每个页面间的应用共享代码创建 bundle。由于入口起点增多，多页应用能够在入口起点重用大量代码/模块，这样可以极大的从这些新技术受益。 根据经验：每个 HTML 文档只使用一个入口起点。]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack2学习(一)]]></title>
    <url>%2F2017%2F01%2F22%2Fwebpack-1%2F</url>
    <content type="text"><![CDATA[webpack2学习（一）概念是一个现代JavaScript应用模块打包器 四个核心概念 入口(Entry) webpack 将创建所有应用程序依赖关系图表(dependency graph)。图表的起点被称之为入口起点(entry point)。入口起点告诉 webpack 从哪里开始，并遵循着依赖关系图表知道打包什么。可以将您的应用入口起点认为是根上下文(contextual root)或 app 第一个启动文件。 在webpack当中使用entry属性来定义入口 webpack.config.js： 123module.exports = &#123; entry: './path/to/my/entry/file.js'&#125;; 出口(Output) webpack 的output属性描述了如何处理打包代码 webpack.config.js 123456789var path = require('path');module.exports = &#123; entry: './path/to/my/entry/file.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'my-first-webpack.bundle.js' &#125;&#125;; 这里的__dirname是指当前模块文件所在目录的完整绝对路径,path定义了打包后出口对应的就是当前目录下的dist文件夹,而打包出来的名字就是底下filename来控制的 加载器(Loader) webpack 的目标是，让项目中的所有资源都成为 webpack 的关注点，而浏览器不需要考虑这些（这并不意味着资源都必须打包在一起）。 webpack 把 每个文件(.css, .html, .scss, .jpg, etc.) 都作为模块 处理。然而 webpack 只了解 JavaScript。 webpack会自己识别出应该被特定的加载器转换的文件 转换能够被添加到依赖图表的文件(并且最终打包) (use属性) webpack.config.js 12345678910111213141516var path = require('path');const config = &#123;entry: './path/to/my/entry/file.js',output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'my-first-webpack.bundle.js'&#125;,module: &#123; rules: [ &#123;test: /\.(js|jsx)$/, use: 'babel-loader'&#125; ]&#125;&#125;;module.exports = config; module当中定义了rules属性,里面必须包含两个属性：test和use，test告诉了webpack编译器在模块被解析为js或者jsx路径时候，你需要把他们先使用babel-loader转换再去打包 注意：在 webpack 配置中定义 loader 时，要定义在 module.rules 中，而不是 rules。在定义错时 webpack 会提出严重的警告。 插件 由于加载器仅基于单个文件执行转换，插件最常用(但不限于)在打包模块的编译和分块时执行操作和自定义功能。 插件的目的是为了解决loader无法实现的其他事情 使用时，只需要require他们，并且把他们添加到plugins数组。由于会出现多次使用插件，因此要使用new来创建插件的实例，并且调用插件。 webpack.config.js 123456789101112131415161718192021const HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npmconst webpack = require('webpack'); //to access built-in pluginsconst config = &#123;entry: './path/to/my/entry/file.js',output: &#123; filename: 'my-first-webpack.bundle.js', path: './dist'&#125;,module: &#123; rules: [ &#123;test: /\.(js|jsx)$/, use: 'babel-loader'&#125; ]&#125;,plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;)]&#125;;module.exports = config;]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
</search>
